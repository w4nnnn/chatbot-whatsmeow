<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# whatsmeow

```go
import "go.mau.fi/whatsmeow"
```

Package whatsmeow implements a client for interacting with the WhatsApp web multidevice API.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"go.mau.fi/whatsmeow"
	"go.mau.fi/whatsmeow/store/sqlstore"
	"go.mau.fi/whatsmeow/types/events"
	waLog "go.mau.fi/whatsmeow/util/log"
)

func eventHandler(evt interface{}) {
	switch v := evt.(type) {
	case *events.Message:
		fmt.Println("Received a message!", v.Message.GetConversation())
	}
}

func main() {
	// |------------------------------------------------------------------------------------------------------|
	// | NOTE: You must also import the appropriate DB connector, e.g. github.com/mattn/go-sqlite3 for SQLite |
	// |------------------------------------------------------------------------------------------------------|

	dbLog := waLog.Stdout("Database", "DEBUG", true)
	ctx := context.Background()
	container, err := sqlstore.New(ctx, "sqlite3", "file:examplestore.db?_foreign_keys=on", dbLog)
	if err != nil {
		panic(err)
	}
	// If you want multiple sessions, remember their JIDs and use .GetDevice(jid) or .GetAllDevices() instead.
	deviceStore, err := container.GetFirstDevice(ctx)
	if err != nil {
		panic(err)
	}
	clientLog := waLog.Stdout("Client", "DEBUG", true)
	client := whatsmeow.NewClient(deviceStore, clientLog)
	client.AddEventHandler(eventHandler)

	if client.Store.ID == nil {
		// No ID stored, new login
		qrChan, _ := client.GetQRChannel(context.Background())
		err = client.Connect()
		if err != nil {
			panic(err)
		}
		for evt := range qrChan {
			if evt.Event == "code" {
				// Render the QR code here
				// e.g. qrterminal.GenerateHalfBlock(evt.Code, qrterminal.L, os.Stdout)
				// or just manually `echo 2@... | qrencode -t ansiutf8` in a terminal
				fmt.Println("QR code:", evt.Code)
			} else {
				fmt.Println("Login event:", evt.Event)
			}
		}
	} else {
		// Already logged in, just connect
		err = client.Connect()
		if err != nil {
			panic(err)
		}
	}

	// Listen to Ctrl+C (you can also do something else that prevents the program from exiting)
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	<-c

	client.Disconnect()
}
```

</p>
</details>

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func DecryptMediaRetryNotification\(evt \*events.MediaRetry, mediaKey \[\]byte\) \(\*waMmsRetry.MediaRetryNotification, error\)](<#DecryptMediaRetryNotification>)
- [func GenerateFacebookMessageID\(\) int64](<#GenerateFacebookMessageID>)
- [func GenerateMessageID\(\) types.MessageID](<#GenerateMessageID>)
- [func GetLatestVersion\(ctx context.Context, httpClient \*http.Client\) \(\*store.WAVersionContainer, error\)](<#GetLatestVersion>)
- [func HashPollOptions\(optionNames \[\]string\) \[\]\[\]byte](<#HashPollOptions>)
- [func ParseDisappearingTimerString\(val string\) \(time.Duration, bool\)](<#ParseDisappearingTimerString>)
- [type APNsPushConfig](<#APNsPushConfig>)
  - [func \(apc \*APNsPushConfig\) GetPushConfigAttrs\(\) waBinary.Attrs](<#APNsPushConfig.GetPushConfigAttrs>)
- [type Client](<#Client>)
  - [func NewClient\(deviceStore \*store.Device, log waLog.Logger\) \*Client](<#NewClient>)
  - [func \(cli \*Client\) AcceptTOSNotice\(ctx context.Context, noticeID, stage string\) error](<#Client.AcceptTOSNotice>)
  - [func \(cli \*Client\) AddEventHandler\(handler EventHandler\) uint32](<#Client.AddEventHandler>)
  - [func \(cli \*Client\) AddEventHandlerWithSuccessStatus\(handler EventHandlerWithSuccessStatus\) uint32](<#Client.AddEventHandlerWithSuccessStatus>)
  - [func \(cli \*Client\) BuildEdit\(chat types.JID, id types.MessageID, newContent \*waE2E.Message\) \*waE2E.Message](<#Client.BuildEdit>)
  - [func \(cli \*Client\) BuildHistorySyncRequest\(lastKnownMessageInfo \*types.MessageInfo, count int\) \*waE2E.Message](<#Client.BuildHistorySyncRequest>)
  - [func \(cli \*Client\) BuildMessageKey\(chat, sender types.JID, id types.MessageID\) \*waCommon.MessageKey](<#Client.BuildMessageKey>)
  - [func \(cli \*Client\) BuildPollCreation\(name string, optionNames \[\]string, selectableOptionCount int\) \*waE2E.Message](<#Client.BuildPollCreation>)
  - [func \(cli \*Client\) BuildPollVote\(ctx context.Context, pollInfo \*types.MessageInfo, optionNames \[\]string\) \(\*waE2E.Message, error\)](<#Client.BuildPollVote>)
  - [func \(cli \*Client\) BuildReaction\(chat, sender types.JID, id types.MessageID, reaction string\) \*waE2E.Message](<#Client.BuildReaction>)
  - [func \(cli \*Client\) BuildRevoke\(chat, sender types.JID, id types.MessageID\) \*waE2E.Message](<#Client.BuildRevoke>)
  - [func \(cli \*Client\) BuildUnavailableMessageRequest\(chat, sender types.JID, id string\) \*waE2E.Message](<#Client.BuildUnavailableMessageRequest>)
  - [func \(cli \*Client\) Connect\(\) error](<#Client.Connect>)
  - [func \(cli \*Client\) ConnectContext\(ctx context.Context\) error](<#Client.ConnectContext>)
  - [func \(cli \*Client\) CreateGroup\(ctx context.Context, req ReqCreateGroup\) \(\*types.GroupInfo, error\)](<#Client.CreateGroup>)
  - [func \(cli \*Client\) CreateNewsletter\(ctx context.Context, params CreateNewsletterParams\) \(\*types.NewsletterMetadata, error\)](<#Client.CreateNewsletter>)
  - [func \(cli \*Client\) DangerousInternals\(\) \*DangerousInternalClient](<#Client.DangerousInternals>)
  - [func \(cli \*Client\) DecryptComment\(ctx context.Context, comment \*events.Message\) \(\*waE2E.Message, error\)](<#Client.DecryptComment>)
  - [func \(cli \*Client\) DecryptPollVote\(ctx context.Context, vote \*events.Message\) \(\*waE2E.PollVoteMessage, error\)](<#Client.DecryptPollVote>)
  - [func \(cli \*Client\) DecryptReaction\(ctx context.Context, reaction \*events.Message\) \(\*waE2E.ReactionMessage, error\)](<#Client.DecryptReaction>)
  - [func \(cli \*Client\) DecryptSecretEncryptedMessage\(ctx context.Context, evt \*events.Message\) \(\*waE2E.Message, error\)](<#Client.DecryptSecretEncryptedMessage>)
  - [func \(cli \*Client\) Disconnect\(\)](<#Client.Disconnect>)
  - [func \(cli \*Client\) Download\(ctx context.Context, msg DownloadableMessage\) \(\[\]byte, error\)](<#Client.Download>)
  - [func \(cli \*Client\) DownloadAny\(ctx context.Context, msg \*waE2E.Message\) \(data \[\]byte, err error\)](<#Client.DownloadAny>)
  - [func \(cli \*Client\) DownloadFB\(ctx context.Context, transport \*waMediaTransport.WAMediaTransport\_Integral, mediaType MediaType\) \(\[\]byte, error\)](<#Client.DownloadFB>)
  - [func \(cli \*Client\) DownloadFBToFile\(ctx context.Context, transport \*waMediaTransport.WAMediaTransport\_Integral, mediaType MediaType, file File\) error](<#Client.DownloadFBToFile>)
  - [func \(cli \*Client\) DownloadHistorySync\(ctx context.Context, notif \*waE2E.HistorySyncNotification, synchronousStorage bool\) \(\*waHistorySync.HistorySync, error\)](<#Client.DownloadHistorySync>)
  - [func \(cli \*Client\) DownloadMediaWithPath\(ctx context.Context, directPath string, encFileHash, fileHash, mediaKey \[\]byte, fileLength int, mediaType MediaType, mmsType string\) \(data \[\]byte, err error\)](<#Client.DownloadMediaWithPath>)
  - [func \(cli \*Client\) DownloadMediaWithPathToFile\(ctx context.Context, directPath string, encFileHash, fileHash, mediaKey \[\]byte, fileLength int, mediaType MediaType, mmsType string, file File\) error](<#Client.DownloadMediaWithPathToFile>)
  - [func \(cli \*Client\) DownloadThumbnail\(ctx context.Context, msg DownloadableThumbnail\) \(\[\]byte, error\)](<#Client.DownloadThumbnail>)
  - [func \(cli \*Client\) DownloadToFile\(ctx context.Context, msg DownloadableMessage, file File\) error](<#Client.DownloadToFile>)
  - [func \(cli \*Client\) EncryptComment\(ctx context.Context, rootMsgInfo \*types.MessageInfo, comment \*waE2E.Message\) \(\*waE2E.Message, error\)](<#Client.EncryptComment>)
  - [func \(cli \*Client\) EncryptPollVote\(ctx context.Context, pollInfo \*types.MessageInfo, vote \*waE2E.PollVoteMessage\) \(\*waE2E.PollUpdateMessage, error\)](<#Client.EncryptPollVote>)
  - [func \(cli \*Client\) EncryptReaction\(ctx context.Context, rootMsgInfo \*types.MessageInfo, reaction \*waE2E.ReactionMessage\) \(\*waE2E.EncReactionMessage, error\)](<#Client.EncryptReaction>)
  - [func \(cli \*Client\) FetchAppState\(ctx context.Context, name appstate.WAPatchName, fullSync, onlyIfNotSynced bool\) error](<#Client.FetchAppState>)
  - [func \(cli \*Client\) FollowNewsletter\(ctx context.Context, jid types.JID\) error](<#Client.FollowNewsletter>)
  - [func \(cli \*Client\) GenerateMessageID\(\) types.MessageID](<#Client.GenerateMessageID>)
  - [func \(cli \*Client\) GetBlocklist\(ctx context.Context\) \(\*types.Blocklist, error\)](<#Client.GetBlocklist>)
  - [func \(cli \*Client\) GetBotListV2\(ctx context.Context\) \(\[\]types.BotListInfo, error\)](<#Client.GetBotListV2>)
  - [func \(cli \*Client\) GetBotProfiles\(ctx context.Context, botInfo \[\]types.BotListInfo\) \(\[\]types.BotProfileInfo, error\)](<#Client.GetBotProfiles>)
  - [func \(cli \*Client\) GetBusinessProfile\(ctx context.Context, jid types.JID\) \(\*types.BusinessProfile, error\)](<#Client.GetBusinessProfile>)
  - [func \(cli \*Client\) GetContactQRLink\(ctx context.Context, revoke bool\) \(string, error\)](<#Client.GetContactQRLink>)
  - [func \(cli \*Client\) GetGroupInfo\(ctx context.Context, jid types.JID\) \(\*types.GroupInfo, error\)](<#Client.GetGroupInfo>)
  - [func \(cli \*Client\) GetGroupInfoFromInvite\(ctx context.Context, jid, inviter types.JID, code string, expiration int64\) \(\*types.GroupInfo, error\)](<#Client.GetGroupInfoFromInvite>)
  - [func \(cli \*Client\) GetGroupInfoFromLink\(ctx context.Context, code string\) \(\*types.GroupInfo, error\)](<#Client.GetGroupInfoFromLink>)
  - [func \(cli \*Client\) GetGroupInviteLink\(ctx context.Context, jid types.JID, reset bool\) \(string, error\)](<#Client.GetGroupInviteLink>)
  - [func \(cli \*Client\) GetGroupRequestParticipants\(ctx context.Context, jid types.JID\) \(\[\]types.GroupParticipantRequest, error\)](<#Client.GetGroupRequestParticipants>)
  - [func \(cli \*Client\) GetJoinedGroups\(ctx context.Context\) \(\[\]\*types.GroupInfo, error\)](<#Client.GetJoinedGroups>)
  - [func \(cli \*Client\) GetLinkedGroupsParticipants\(ctx context.Context, community types.JID\) \(\[\]types.JID, error\)](<#Client.GetLinkedGroupsParticipants>)
  - [func \(cli \*Client\) GetNewsletterInfo\(ctx context.Context, jid types.JID\) \(\*types.NewsletterMetadata, error\)](<#Client.GetNewsletterInfo>)
  - [func \(cli \*Client\) GetNewsletterInfoWithInvite\(ctx context.Context, key string\) \(\*types.NewsletterMetadata, error\)](<#Client.GetNewsletterInfoWithInvite>)
  - [func \(cli \*Client\) GetNewsletterMessageUpdates\(ctx context.Context, jid types.JID, params \*GetNewsletterUpdatesParams\) \(\[\]\*types.NewsletterMessage, error\)](<#Client.GetNewsletterMessageUpdates>)
  - [func \(cli \*Client\) GetNewsletterMessages\(ctx context.Context, jid types.JID, params \*GetNewsletterMessagesParams\) \(\[\]\*types.NewsletterMessage, error\)](<#Client.GetNewsletterMessages>)
  - [func \(cli \*Client\) GetPrivacySettings\(ctx context.Context\) \(settings types.PrivacySettings\)](<#Client.GetPrivacySettings>)
  - [func \(cli \*Client\) GetProfilePictureInfo\(ctx context.Context, jid types.JID, params \*GetProfilePictureParams\) \(\*types.ProfilePictureInfo, error\)](<#Client.GetProfilePictureInfo>)
  - [func \(cli \*Client\) GetQRChannel\(ctx context.Context\) \(\<\-chan QRChannelItem, error\)](<#Client.GetQRChannel>)
  - [func \(cli \*Client\) GetServerPushNotificationConfig\(ctx context.Context\) \(\*waBinary.Node, error\)](<#Client.GetServerPushNotificationConfig>)
  - [func \(cli \*Client\) GetStatusPrivacy\(ctx context.Context\) \(\[\]types.StatusPrivacy, error\)](<#Client.GetStatusPrivacy>)
  - [func \(cli \*Client\) GetSubGroups\(ctx context.Context, community types.JID\) \(\[\]\*types.GroupLinkTarget, error\)](<#Client.GetSubGroups>)
  - [func \(cli \*Client\) GetSubscribedNewsletters\(ctx context.Context\) \(\[\]\*types.NewsletterMetadata, error\)](<#Client.GetSubscribedNewsletters>)
  - [func \(cli \*Client\) GetUserDevices\(ctx context.Context, jids \[\]types.JID\) \(\[\]types.JID, error\)](<#Client.GetUserDevices>)
  - [func \(cli \*Client\) GetUserDevicesContext\(ctx context.Context, jids \[\]types.JID\) \(\[\]types.JID, error\)](<#Client.GetUserDevicesContext>)
  - [func \(cli \*Client\) GetUserInfo\(ctx context.Context, jids \[\]types.JID\) \(map\[types.JID\]types.UserInfo, error\)](<#Client.GetUserInfo>)
  - [func \(cli \*Client\) IsConnected\(\) bool](<#Client.IsConnected>)
  - [func \(cli \*Client\) IsLoggedIn\(\) bool](<#Client.IsLoggedIn>)
  - [func \(cli \*Client\) IsOnWhatsApp\(ctx context.Context, phones \[\]string\) \(\[\]types.IsOnWhatsAppResponse, error\)](<#Client.IsOnWhatsApp>)
  - [func \(cli \*Client\) JoinGroupWithInvite\(ctx context.Context, jid, inviter types.JID, code string, expiration int64\) error](<#Client.JoinGroupWithInvite>)
  - [func \(cli \*Client\) JoinGroupWithLink\(ctx context.Context, code string\) \(types.JID, error\)](<#Client.JoinGroupWithLink>)
  - [func \(cli \*Client\) LeaveGroup\(ctx context.Context, jid types.JID\) error](<#Client.LeaveGroup>)
  - [func \(cli \*Client\) LinkGroup\(ctx context.Context, parent, child types.JID\) error](<#Client.LinkGroup>)
  - [func \(cli \*Client\) Logout\(ctx context.Context\) error](<#Client.Logout>)
  - [func \(cli \*Client\) MarkNotDirty\(ctx context.Context, cleanType string, ts time.Time\) error](<#Client.MarkNotDirty>)
  - [func \(cli \*Client\) MarkRead\(ctx context.Context, ids \[\]types.MessageID, timestamp time.Time, chat, sender types.JID, receiptTypeExtra ...types.ReceiptType\) error](<#Client.MarkRead>)
  - [func \(cli \*Client\) NewsletterMarkViewed\(ctx context.Context, jid types.JID, serverIDs \[\]types.MessageServerID\) error](<#Client.NewsletterMarkViewed>)
  - [func \(cli \*Client\) NewsletterSendReaction\(ctx context.Context, jid types.JID, serverID types.MessageServerID, reaction string, messageID types.MessageID\) error](<#Client.NewsletterSendReaction>)
  - [func \(cli \*Client\) NewsletterSubscribeLiveUpdates\(ctx context.Context, jid types.JID\) \(time.Duration, error\)](<#Client.NewsletterSubscribeLiveUpdates>)
  - [func \(cli \*Client\) NewsletterToggleMute\(ctx context.Context, jid types.JID, mute bool\) error](<#Client.NewsletterToggleMute>)
  - [func \(cli \*Client\) PairPhone\(ctx context.Context, phone string, showPushNotification bool, clientType PairClientType, clientDisplayName string\) \(string, error\)](<#Client.PairPhone>)
  - [func \(cli \*Client\) ParseWebMessage\(chatJID types.JID, webMsg \*waWeb.WebMessageInfo\) \(\*events.Message, error\)](<#Client.ParseWebMessage>)
  - [func \(cli \*Client\) RegisterForPushNotifications\(ctx context.Context, pc PushConfig\) error](<#Client.RegisterForPushNotifications>)
  - [func \(cli \*Client\) RejectCall\(ctx context.Context, callFrom types.JID, callID string\) error](<#Client.RejectCall>)
  - [func \(cli \*Client\) RemoveEventHandler\(id uint32\) bool](<#Client.RemoveEventHandler>)
  - [func \(cli \*Client\) RemoveEventHandlers\(\)](<#Client.RemoveEventHandlers>)
  - [func \(cli \*Client\) ResetConnection\(\)](<#Client.ResetConnection>)
  - [func \(cli \*Client\) ResolveBusinessMessageLink\(ctx context.Context, code string\) \(\*types.BusinessMessageLinkTarget, error\)](<#Client.ResolveBusinessMessageLink>)
  - [func \(cli \*Client\) ResolveContactQRLink\(ctx context.Context, code string\) \(\*types.ContactQRLinkTarget, error\)](<#Client.ResolveContactQRLink>)
  - [func \(cli \*Client\) RevokeMessage\(ctx context.Context, chat types.JID, id types.MessageID\) \(SendResponse, error\)](<#Client.RevokeMessage>)
  - [func \(cli \*Client\) SendAppState\(ctx context.Context, patch appstate.PatchInfo\) error](<#Client.SendAppState>)
  - [func \(cli \*Client\) SendChatPresence\(ctx context.Context, jid types.JID, state types.ChatPresence, media types.ChatPresenceMedia\) error](<#Client.SendChatPresence>)
  - [func \(cli \*Client\) SendFBMessage\(ctx context.Context, to types.JID, message armadillo.RealMessageApplicationSub, metadata \*waMsgApplication.MessageApplication\_Metadata, extra ...SendRequestExtra\) \(resp SendResponse, err error\)](<#Client.SendFBMessage>)
  - [func \(cli \*Client\) SendMediaRetryReceipt\(ctx context.Context, message \*types.MessageInfo, mediaKey \[\]byte\) error](<#Client.SendMediaRetryReceipt>)
  - [func \(cli \*Client\) SendMessage\(ctx context.Context, to types.JID, message \*waE2E.Message, extra ...SendRequestExtra\) \(resp SendResponse, err error\)](<#Client.SendMessage>)
  - [func \(cli \*Client\) SendPresence\(ctx context.Context, state types.Presence\) error](<#Client.SendPresence>)
  - [func \(cli \*Client\) SetDefaultDisappearingTimer\(ctx context.Context, timer time.Duration\) \(err error\)](<#Client.SetDefaultDisappearingTimer>)
  - [func \(cli \*Client\) SetDisappearingTimer\(ctx context.Context, chat types.JID, timer time.Duration, settingTS time.Time\) \(err error\)](<#Client.SetDisappearingTimer>)
  - [func \(cli \*Client\) SetForceActiveDeliveryReceipts\(active bool\)](<#Client.SetForceActiveDeliveryReceipts>)
  - [func \(cli \*Client\) SetGroupAnnounce\(ctx context.Context, jid types.JID, announce bool\) error](<#Client.SetGroupAnnounce>)
  - [func \(cli \*Client\) SetGroupDescription\(ctx context.Context, jid types.JID, description string\) error](<#Client.SetGroupDescription>)
  - [func \(cli \*Client\) SetGroupJoinApprovalMode\(ctx context.Context, jid types.JID, mode bool\) error](<#Client.SetGroupJoinApprovalMode>)
  - [func \(cli \*Client\) SetGroupLocked\(ctx context.Context, jid types.JID, locked bool\) error](<#Client.SetGroupLocked>)
  - [func \(cli \*Client\) SetGroupMemberAddMode\(ctx context.Context, jid types.JID, mode types.GroupMemberAddMode\) error](<#Client.SetGroupMemberAddMode>)
  - [func \(cli \*Client\) SetGroupName\(ctx context.Context, jid types.JID, name string\) error](<#Client.SetGroupName>)
  - [func \(cli \*Client\) SetGroupPhoto\(ctx context.Context, jid types.JID, avatar \[\]byte\) \(string, error\)](<#Client.SetGroupPhoto>)
  - [func \(cli \*Client\) SetGroupTopic\(ctx context.Context, jid types.JID, previousID, newID, topic string\) error](<#Client.SetGroupTopic>)
  - [func \(cli \*Client\) SetMediaHTTPClient\(h \*http.Client\)](<#Client.SetMediaHTTPClient>)
  - [func \(cli \*Client\) SetPassive\(ctx context.Context, passive bool\) error](<#Client.SetPassive>)
  - [func \(cli \*Client\) SetPreLoginHTTPClient\(h \*http.Client\)](<#Client.SetPreLoginHTTPClient>)
  - [func \(cli \*Client\) SetPrivacySetting\(ctx context.Context, name types.PrivacySettingType, value types.PrivacySetting\) \(settings types.PrivacySettings, err error\)](<#Client.SetPrivacySetting>)
  - [func \(cli \*Client\) SetProxy\(proxy Proxy, opts ...SetProxyOptions\)](<#Client.SetProxy>)
  - [func \(cli \*Client\) SetProxyAddress\(addr string, opts ...SetProxyOptions\) error](<#Client.SetProxyAddress>)
  - [func \(cli \*Client\) SetSOCKSProxy\(px proxy.Dialer, opts ...SetProxyOptions\)](<#Client.SetSOCKSProxy>)
  - [func \(cli \*Client\) SetStatusMessage\(ctx context.Context, msg string\) error](<#Client.SetStatusMessage>)
  - [func \(cli \*Client\) SetWebsocketHTTPClient\(h \*http.Client\)](<#Client.SetWebsocketHTTPClient>)
  - [func \(cli \*Client\) StoreLIDPNMapping\(ctx context.Context, first, second types.JID\)](<#Client.StoreLIDPNMapping>)
  - [func \(cli \*Client\) SubscribePresence\(ctx context.Context, jid types.JID\) error](<#Client.SubscribePresence>)
  - [func \(cli \*Client\) TryFetchPrivacySettings\(ctx context.Context, ignoreCache bool\) \(\*types.PrivacySettings, error\)](<#Client.TryFetchPrivacySettings>)
  - [func \(cli \*Client\) UnfollowNewsletter\(ctx context.Context, jid types.JID\) error](<#Client.UnfollowNewsletter>)
  - [func \(cli \*Client\) UnlinkGroup\(ctx context.Context, parent, child types.JID\) error](<#Client.UnlinkGroup>)
  - [func \(cli \*Client\) UpdateBlocklist\(ctx context.Context, jid types.JID, action events.BlocklistChangeAction\) \(\*types.Blocklist, error\)](<#Client.UpdateBlocklist>)
  - [func \(cli \*Client\) UpdateGroupParticipants\(ctx context.Context, jid types.JID, participantChanges \[\]types.JID, action ParticipantChange\) \(\[\]types.GroupParticipant, error\)](<#Client.UpdateGroupParticipants>)
  - [func \(cli \*Client\) UpdateGroupRequestParticipants\(ctx context.Context, jid types.JID, participantChanges \[\]types.JID, action ParticipantRequestChange\) \(\[\]types.GroupParticipant, error\)](<#Client.UpdateGroupRequestParticipants>)
  - [func \(cli \*Client\) Upload\(ctx context.Context, plaintext \[\]byte, appInfo MediaType\) \(resp UploadResponse, err error\)](<#Client.Upload>)
  - [func \(cli \*Client\) UploadNewsletter\(ctx context.Context, data \[\]byte, appInfo MediaType\) \(resp UploadResponse, err error\)](<#Client.UploadNewsletter>)
  - [func \(cli \*Client\) UploadNewsletterReader\(ctx context.Context, data io.ReadSeeker, appInfo MediaType\) \(resp UploadResponse, err error\)](<#Client.UploadNewsletterReader>)
  - [func \(cli \*Client\) UploadReader\(ctx context.Context, plaintext io.Reader, tempFile io.ReadWriteSeeker, appInfo MediaType\) \(resp UploadResponse, err error\)](<#Client.UploadReader>)
  - [func \(cli \*Client\) WaitForConnection\(timeout time.Duration\) bool](<#Client.WaitForConnection>)
- [type CreateNewsletterParams](<#CreateNewsletterParams>)
- [type DangerousInfoQuery](<#DangerousInfoQuery>)
- [type DangerousInfoQueryType](<#DangerousInfoQueryType>)
- [type DangerousInternalClient](<#DangerousInternalClient>)
  - [func \(int \*DangerousInternalClient\) AddRecentMessage\(to types.JID, id types.MessageID, wa \*waE2E.Message, fb \*waMsgApplication.MessageApplication\)](<#DangerousInternalClient.AddRecentMessage>)
  - [func \(int \*DangerousInternalClient\) ApplyAppStatePatches\(ctx context.Context, name appstate.WAPatchName, state appstate.HashState, patches \*appstate.PatchList, fullSync bool, eventsToDispatch \*\[\]any\) \(appstate.HashState, error\)](<#DangerousInternalClient.ApplyAppStatePatches>)
  - [func \(int \*DangerousInternalClient\) AutoReconnect\(ctx context.Context\)](<#DangerousInternalClient.AutoReconnect>)
  - [func \(int \*DangerousInternalClient\) BackgroundIfAsyncAck\(fn func\(\)\)](<#DangerousInternalClient.BackgroundIfAsyncAck>)
  - [func \(int \*DangerousInternalClient\) BufferedDecrypt\(ctx context.Context, ciphertext \[\]byte, serverTimestamp time.Time, decrypt func\(context.Context\) \(\[\]byte, error\)\) \(plaintext \[\]byte, ciphertextHash \[32\]byte, err error\)](<#DangerousInternalClient.BufferedDecrypt>)
  - [func \(int \*DangerousInternalClient\) CacheGroupInfo\(groupInfo \*types.GroupInfo, lock bool\) \(\[\]store.LIDMapping, \[\]store.RedactedPhoneEntry\)](<#DangerousInternalClient.CacheGroupInfo>)
  - [func \(int \*DangerousInternalClient\) CancelDelayedRequestFromPhone\(msgID types.MessageID\)](<#DangerousInternalClient.CancelDelayedRequestFromPhone>)
  - [func \(int \*DangerousInternalClient\) CancelResponse\(reqID string, ch chan \*waBinary.Node\)](<#DangerousInternalClient.CancelResponse>)
  - [func \(int \*DangerousInternalClient\) ClearDelayedMessageRequests\(\)](<#DangerousInternalClient.ClearDelayedMessageRequests>)
  - [func \(int \*DangerousInternalClient\) ClearResponseWaiters\(node \*waBinary.Node\)](<#DangerousInternalClient.ClearResponseWaiters>)
  - [func \(int \*DangerousInternalClient\) ClearUntrustedIdentity\(ctx context.Context, target types.JID\) error](<#DangerousInternalClient.ClearUntrustedIdentity>)
  - [func \(int \*DangerousInternalClient\) CloseSocketWaitChan\(\)](<#DangerousInternalClient.CloseSocketWaitChan>)
  - [func \(int \*DangerousInternalClient\) Connect\(ctx context.Context\) error](<#DangerousInternalClient.Connect>)
  - [func \(int \*DangerousInternalClient\) DecryptBotMessage\(ctx context.Context, messageSecret \[\]byte, msMsg messageEncryptedSecret, messageID types.MessageID, targetSenderJID types.JID, info \*types.MessageInfo\) \(\[\]byte, error\)](<#DangerousInternalClient.DecryptBotMessage>)
  - [func \(int \*DangerousInternalClient\) DecryptDM\(ctx context.Context, child \*waBinary.Node, from types.JID, isPreKey bool, serverTS time.Time\) \(\[\]byte, \*\[32\]byte, error\)](<#DangerousInternalClient.DecryptDM>)
  - [func \(int \*DangerousInternalClient\) DecryptGroupMsg\(ctx context.Context, child \*waBinary.Node, from types.JID, chat types.JID, serverTS time.Time\) \(\[\]byte, \*\[32\]byte, error\)](<#DangerousInternalClient.DecryptGroupMsg>)
  - [func \(int \*DangerousInternalClient\) DecryptMessages\(ctx context.Context, info \*types.MessageInfo, node \*waBinary.Node\)](<#DangerousInternalClient.DecryptMessages>)
  - [func \(int \*DangerousInternalClient\) DecryptMsgSecret\(ctx context.Context, msg \*events.Message, useCase MsgSecretType, encrypted messageEncryptedSecret, origMsgKey \*waCommon.MessageKey\) \(\[\]byte, error\)](<#DangerousInternalClient.DecryptMsgSecret>)
  - [func \(int \*DangerousInternalClient\) DelayedRequestMessageFromPhone\(info \*types.MessageInfo\)](<#DangerousInternalClient.DelayedRequestMessageFromPhone>)
  - [func \(int \*DangerousInternalClient\) DispatchAppState\(ctx context.Context, mutation appstate.Mutation, fullSync bool\) \(eventToDispatch any\)](<#DangerousInternalClient.DispatchAppState>)
  - [func \(int \*DangerousInternalClient\) DispatchEvent\(evt any\) \(handlerFailed bool\)](<#DangerousInternalClient.DispatchEvent>)
  - [func \(int \*DangerousInternalClient\) DoHandshake\(ctx context.Context, fs \*socket.FrameSocket, ephemeralKP keys.KeyPair\) error](<#DangerousInternalClient.DoHandshake>)
  - [func \(int \*DangerousInternalClient\) DoMediaDownloadRequest\(ctx context.Context, url string\) \(\*http.Response, error\)](<#DangerousInternalClient.DoMediaDownloadRequest>)
  - [func \(int \*DangerousInternalClient\) DownloadAndDecrypt\(ctx context.Context, url string, mediaKey \[\]byte, appInfo MediaType, fileLength int, fileEncSHA256, fileSHA256 \[\]byte\) \(data \[\]byte, err error\)](<#DangerousInternalClient.DownloadAndDecrypt>)
  - [func \(int \*DangerousInternalClient\) DownloadAndDecryptToFile\(ctx context.Context, url string, mediaKey \[\]byte, appInfo MediaType, fileLength int, fileEncSHA256, fileSHA256 \[\]byte, file File\) error](<#DangerousInternalClient.DownloadAndDecryptToFile>)
  - [func \(int \*DangerousInternalClient\) DownloadEncryptedMedia\(ctx context.Context, url string, checksum \[\]byte\) \(file, mac \[\]byte, err error\)](<#DangerousInternalClient.DownloadEncryptedMedia>)
  - [func \(int \*DangerousInternalClient\) DownloadEncryptedMediaToFile\(ctx context.Context, url string, checksum \[\]byte, file File\) \(\[\]byte, error\)](<#DangerousInternalClient.DownloadEncryptedMediaToFile>)
  - [func \(int \*DangerousInternalClient\) DownloadExternalAppStateBlob\(ctx context.Context, ref \*waServerSync.ExternalBlobReference\) \(\[\]byte, error\)](<#DangerousInternalClient.DownloadExternalAppStateBlob>)
  - [func \(int \*DangerousInternalClient\) DownloadMedia\(ctx context.Context, url string\) \(\[\]byte, error\)](<#DangerousInternalClient.DownloadMedia>)
  - [func \(int \*DangerousInternalClient\) DownloadMediaToFile\(ctx context.Context, url string, file io.Writer\) \(int64, \[\]byte, error\)](<#DangerousInternalClient.DownloadMediaToFile>)
  - [func \(int \*DangerousInternalClient\) DownloadPossiblyEncryptedMediaWithRetries\(ctx context.Context, url string, checksum \[\]byte\) \(file, mac \[\]byte, err error\)](<#DangerousInternalClient.DownloadPossiblyEncryptedMediaWithRetries>)
  - [func \(int \*DangerousInternalClient\) DownloadPossiblyEncryptedMediaWithRetriesToFile\(ctx context.Context, url string, checksum \[\]byte, file File\) \(mac \[\]byte, err error\)](<#DangerousInternalClient.DownloadPossiblyEncryptedMediaWithRetriesToFile>)
  - [func \(int \*DangerousInternalClient\) EncryptMessageForDevice\(ctx context.Context, plaintext \[\]byte, to types.JID, bundle \*prekey.Bundle, extraAttrs waBinary.Attrs, existingSessions map\[string\]bool\) \(\*waBinary.Node, bool, error\)](<#DangerousInternalClient.EncryptMessageForDevice>)
  - [func \(int \*DangerousInternalClient\) EncryptMessageForDeviceAndWrap\(ctx context.Context, plaintext \[\]byte, wireIdentity, encryptionIdentity types.JID, bundle \*prekey.Bundle, encAttrs waBinary.Attrs, existingSessions map\[string\]bool\) \(\*waBinary.Node, bool, error\)](<#DangerousInternalClient.EncryptMessageForDeviceAndWrap>)
  - [func \(int \*DangerousInternalClient\) EncryptMessageForDeviceAndWrapV3\(ctx context.Context, payload \*waMsgTransport.MessageTransport\_Payload, skdm \*waMsgTransport.MessageTransport\_Protocol\_Ancillary\_SenderKeyDistributionMessage, dsm \*waMsgTransport.MessageTransport\_Protocol\_Integral\_DeviceSentMessage, to types.JID, bundle \*prekey.Bundle, encAttrs waBinary.Attrs\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.EncryptMessageForDeviceAndWrapV3>)
  - [func \(int \*DangerousInternalClient\) EncryptMessageForDeviceV3\(ctx context.Context, payload \*waMsgTransport.MessageTransport\_Payload, skdm \*waMsgTransport.MessageTransport\_Protocol\_Ancillary\_SenderKeyDistributionMessage, dsm \*waMsgTransport.MessageTransport\_Protocol\_Integral\_DeviceSentMessage, to types.JID, bundle \*prekey.Bundle, extraAttrs waBinary.Attrs\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.EncryptMessageForDeviceV3>)
  - [func \(int \*DangerousInternalClient\) EncryptMessageForDevices\(ctx context.Context, allDevices \[\]types.JID, id string, msgPlaintext, dsmPlaintext \[\]byte, encAttrs waBinary.Attrs\) \(\[\]waBinary.Node, bool, error\)](<#DangerousInternalClient.EncryptMessageForDevices>)
  - [func \(int \*DangerousInternalClient\) EncryptMessageForDevicesV3\(ctx context.Context, allDevices \[\]types.JID, ownID types.JID, id string, payload \*waMsgTransport.MessageTransport\_Payload, skdm \*waMsgTransport.MessageTransport\_Protocol\_Ancillary\_SenderKeyDistributionMessage, dsm \*waMsgTransport.MessageTransport\_Protocol\_Integral\_DeviceSentMessage, encAttrs waBinary.Attrs\) \(\[\]waBinary.Node, error\)](<#DangerousInternalClient.EncryptMessageForDevicesV3>)
  - [func \(int \*DangerousInternalClient\) EncryptMsgSecret\(ctx context.Context, ownID, chat, origSender types.JID, origMsgID types.MessageID, useCase MsgSecretType, plaintext \[\]byte\) \(ciphertext, iv \[\]byte, err error\)](<#DangerousInternalClient.EncryptMsgSecret>)
  - [func \(int \*DangerousInternalClient\) ExpectDisconnect\(\)](<#DangerousInternalClient.ExpectDisconnect>)
  - [func \(int \*DangerousInternalClient\) FetchAppState\(ctx context.Context, name appstate.WAPatchName, fullSync, onlyIfNotSynced bool\) \(\[\]any, error\)](<#DangerousInternalClient.FetchAppState>)
  - [func \(int \*DangerousInternalClient\) FetchAppStatePatches\(ctx context.Context, name appstate.WAPatchName, fromVersion uint64, snapshot bool\) \(\*appstate.PatchList, error\)](<#DangerousInternalClient.FetchAppStatePatches>)
  - [func \(int \*DangerousInternalClient\) FetchPreKeys\(ctx context.Context, users \[\]types.JID\) \(map\[types.JID\]preKeyResp, error\)](<#DangerousInternalClient.FetchPreKeys>)
  - [func \(int \*DangerousInternalClient\) FetchPreKeysNoError\(ctx context.Context, retryDevices \[\]types.JID\) map\[types.JID\]\*prekey.Bundle](<#DangerousInternalClient.FetchPreKeysNoError>)
  - [func \(int \*DangerousInternalClient\) FilterContacts\(mutations \[\]appstate.Mutation\) \(\[\]appstate.Mutation, \[\]store.ContactEntry\)](<#DangerousInternalClient.FilterContacts>)
  - [func \(int \*DangerousInternalClient\) GenerateRequestID\(\) string](<#DangerousInternalClient.GenerateRequestID>)
  - [func \(int \*DangerousInternalClient\) GetBroadcastListParticipants\(ctx context.Context, jid types.JID\) \(\[\]types.JID, error\)](<#DangerousInternalClient.GetBroadcastListParticipants>)
  - [func \(int \*DangerousInternalClient\) GetCachedGroupData\(ctx context.Context, jid types.JID\) \(\*groupMetaCache, error\)](<#DangerousInternalClient.GetCachedGroupData>)
  - [func \(int \*DangerousInternalClient\) GetFBIDDevices\(ctx context.Context, jids \[\]types.JID\) \(\[\]types.JID, error\)](<#DangerousInternalClient.GetFBIDDevices>)
  - [func \(int \*DangerousInternalClient\) GetFBIDDevicesInternal\(ctx context.Context, jids \[\]types.JID\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.GetFBIDDevicesInternal>)
  - [func \(int \*DangerousInternalClient\) GetGroupInfo\(ctx context.Context, jid types.JID, lockParticipantCache bool\) \(\*types.GroupInfo, error\)](<#DangerousInternalClient.GetGroupInfo>)
  - [func \(int \*DangerousInternalClient\) GetMessageContent\(baseNode waBinary.Node, message \*waE2E.Message, msgAttrs waBinary.Attrs, includeIdentity bool, extraParams nodeExtraParams\) \[\]waBinary.Node](<#DangerousInternalClient.GetMessageContent>)
  - [func \(int \*DangerousInternalClient\) GetMessageForRetry\(ctx context.Context, receipt \*events.Receipt, messageID types.MessageID\) \(RecentMessage, error\)](<#DangerousInternalClient.GetMessageForRetry>)
  - [func \(int \*DangerousInternalClient\) GetMessageReportingToken\(msgProtobuf \[\]byte, msg \*waE2E.Message, senderJID, remoteJID types.JID, messageID types.MessageID\) waBinary.Node](<#DangerousInternalClient.GetMessageReportingToken>)
  - [func \(int \*DangerousInternalClient\) GetNewsletterInfo\(ctx context.Context, input map\[string\]any, fetchViewerMeta bool\) \(\*types.NewsletterMetadata, error\)](<#DangerousInternalClient.GetNewsletterInfo>)
  - [func \(int \*DangerousInternalClient\) GetOwnID\(\) types.JID](<#DangerousInternalClient.GetOwnID>)
  - [func \(int \*DangerousInternalClient\) GetOwnLID\(\) types.JID](<#DangerousInternalClient.GetOwnLID>)
  - [func \(int \*DangerousInternalClient\) GetRecentMessage\(to types.JID, id types.MessageID\) RecentMessage](<#DangerousInternalClient.GetRecentMessage>)
  - [func \(int \*DangerousInternalClient\) GetServerPreKeyCount\(ctx context.Context\) \(int, error\)](<#DangerousInternalClient.GetServerPreKeyCount>)
  - [func \(int \*DangerousInternalClient\) GetSocketWaitChan\(\) \<\-chan struct\{\}](<#DangerousInternalClient.GetSocketWaitChan>)
  - [func \(int \*DangerousInternalClient\) GetStatusBroadcastRecipients\(ctx context.Context\) \(\[\]types.JID, error\)](<#DangerousInternalClient.GetStatusBroadcastRecipients>)
  - [func \(int \*DangerousInternalClient\) HandleAccountSyncNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleAccountSyncNotification>)
  - [func \(int \*DangerousInternalClient\) HandleAppStateNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleAppStateNotification>)
  - [func \(int \*DangerousInternalClient\) HandleAppStateSyncKeyShare\(ctx context.Context, keys \*waE2E.AppStateSyncKeyShare\)](<#DangerousInternalClient.HandleAppStateSyncKeyShare>)
  - [func \(int \*DangerousInternalClient\) HandleBlocklist\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleBlocklist>)
  - [func \(int \*DangerousInternalClient\) HandleCallEvent\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleCallEvent>)
  - [func \(int \*DangerousInternalClient\) HandleChatState\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleChatState>)
  - [func \(int \*DangerousInternalClient\) HandleCodePairNotification\(ctx context.Context, parentNode \*waBinary.Node\) error](<#DangerousInternalClient.HandleCodePairNotification>)
  - [func \(int \*DangerousInternalClient\) HandleConnectFailure\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleConnectFailure>)
  - [func \(int \*DangerousInternalClient\) HandleConnectSuccess\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleConnectSuccess>)
  - [func \(int \*DangerousInternalClient\) HandleDecryptedArmadillo\(ctx context.Context, info \*types.MessageInfo, decrypted \[\]byte, retryCount int\) \(handlerFailed, protobufFailed bool\)](<#DangerousInternalClient.HandleDecryptedArmadillo>)
  - [func \(int \*DangerousInternalClient\) HandleDecryptedMessage\(ctx context.Context, info \*types.MessageInfo, msg \*waE2E.Message, retryCount int\) bool](<#DangerousInternalClient.HandleDecryptedMessage>)
  - [func \(int \*DangerousInternalClient\) HandleDeviceNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleDeviceNotification>)
  - [func \(int \*DangerousInternalClient\) HandleEncryptNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleEncryptNotification>)
  - [func \(int \*DangerousInternalClient\) HandleEncryptedMessage\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleEncryptedMessage>)
  - [func \(int \*DangerousInternalClient\) HandleFBDeviceNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleFBDeviceNotification>)
  - [func \(int \*DangerousInternalClient\) HandleFrame\(ctx context.Context, data \[\]byte\)](<#DangerousInternalClient.HandleFrame>)
  - [func \(int \*DangerousInternalClient\) HandleGroupedReceipt\(partialReceipt events.Receipt, participants \*waBinary.Node\)](<#DangerousInternalClient.HandleGroupedReceipt>)
  - [func \(int \*DangerousInternalClient\) HandleHistoricalPushNames\(ctx context.Context, names \[\]\*waHistorySync.Pushname\)](<#DangerousInternalClient.HandleHistoricalPushNames>)
  - [func \(int \*DangerousInternalClient\) HandleHistorySyncNotificationLoop\(\)](<#DangerousInternalClient.HandleHistorySyncNotificationLoop>)
  - [func \(int \*DangerousInternalClient\) HandleIB\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleIB>)
  - [func \(int \*DangerousInternalClient\) HandleIQ\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleIQ>)
  - [func \(int \*DangerousInternalClient\) HandleMediaRetryNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleMediaRetryNotification>)
  - [func \(int \*DangerousInternalClient\) HandleMexNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleMexNotification>)
  - [func \(int \*DangerousInternalClient\) HandleNewsletterNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleNewsletterNotification>)
  - [func \(int \*DangerousInternalClient\) HandleNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleNotification>)
  - [func \(int \*DangerousInternalClient\) HandleOwnDevicesNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleOwnDevicesNotification>)
  - [func \(int \*DangerousInternalClient\) HandlePair\(ctx context.Context, deviceIdentityBytes \[\]byte, reqID, businessName, platform string, jid, lid types.JID\) error](<#DangerousInternalClient.HandlePair>)
  - [func \(int \*DangerousInternalClient\) HandlePairDevice\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandlePairDevice>)
  - [func \(int \*DangerousInternalClient\) HandlePairSuccess\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandlePairSuccess>)
  - [func \(int \*DangerousInternalClient\) HandlePictureNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandlePictureNotification>)
  - [func \(int \*DangerousInternalClient\) HandlePlaceholderResendResponse\(msg \*waE2E.PeerDataOperationRequestResponseMessage\) \(ok bool\)](<#DangerousInternalClient.HandlePlaceholderResendResponse>)
  - [func \(int \*DangerousInternalClient\) HandlePlaintextMessage\(ctx context.Context, info \*types.MessageInfo, node \*waBinary.Node\) \(handlerFailed bool\)](<#DangerousInternalClient.HandlePlaintextMessage>)
  - [func \(int \*DangerousInternalClient\) HandlePresence\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandlePresence>)
  - [func \(int \*DangerousInternalClient\) HandlePrivacySettingsNotification\(ctx context.Context, privacyNode \*waBinary.Node\)](<#DangerousInternalClient.HandlePrivacySettingsNotification>)
  - [func \(int \*DangerousInternalClient\) HandlePrivacyTokenNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandlePrivacyTokenNotification>)
  - [func \(int \*DangerousInternalClient\) HandleProtocolMessage\(ctx context.Context, info \*types.MessageInfo, msg \*waE2E.Message\) \(ok bool\)](<#DangerousInternalClient.HandleProtocolMessage>)
  - [func \(int \*DangerousInternalClient\) HandleReceipt\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleReceipt>)
  - [func \(int \*DangerousInternalClient\) HandleRetryReceipt\(ctx context.Context, receipt \*events.Receipt, node \*waBinary.Node\) error](<#DangerousInternalClient.HandleRetryReceipt>)
  - [func \(int \*DangerousInternalClient\) HandleSenderKeyDistributionMessage\(ctx context.Context, chat, from types.JID, axolotlSKDM \[\]byte\)](<#DangerousInternalClient.HandleSenderKeyDistributionMessage>)
  - [func \(int \*DangerousInternalClient\) HandleStatusNotification\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleStatusNotification>)
  - [func \(int \*DangerousInternalClient\) HandleStreamError\(ctx context.Context, node \*waBinary.Node\)](<#DangerousInternalClient.HandleStreamError>)
  - [func \(int \*DangerousInternalClient\) HandlerQueueLoop\(evtCtx, connCtx context.Context\)](<#DangerousInternalClient.HandlerQueueLoop>)
  - [func \(int \*DangerousInternalClient\) ImmediateRequestMessageFromPhone\(ctx context.Context, info \*types.MessageInfo\)](<#DangerousInternalClient.ImmediateRequestMessageFromPhone>)
  - [func \(int \*DangerousInternalClient\) IsExpectedDisconnect\(\) bool](<#DangerousInternalClient.IsExpectedDisconnect>)
  - [func \(int \*DangerousInternalClient\) KeepAliveLoop\(ctx, connCtx context.Context\)](<#DangerousInternalClient.KeepAliveLoop>)
  - [func \(int \*DangerousInternalClient\) MakeDeviceIdentityNode\(\) waBinary.Node](<#DangerousInternalClient.MakeDeviceIdentityNode>)
  - [func \(int \*DangerousInternalClient\) MakeQRData\(ref string\) string](<#DangerousInternalClient.MakeQRData>)
  - [func \(int \*DangerousInternalClient\) MaybeDeferredAck\(ctx context.Context, node \*waBinary.Node\) func\(...\*bool\)](<#DangerousInternalClient.MaybeDeferredAck>)
  - [func \(int \*DangerousInternalClient\) MigrateSessionStore\(ctx context.Context, pn, lid types.JID\)](<#DangerousInternalClient.MigrateSessionStore>)
  - [func \(int \*DangerousInternalClient\) OnDisconnect\(ctx context.Context, ns \*socket.NoiseSocket, remote bool\)](<#DangerousInternalClient.OnDisconnect>)
  - [func \(int \*DangerousInternalClient\) ParseBlocklist\(node \*waBinary.Node\) \*types.Blocklist](<#DangerousInternalClient.ParseBlocklist>)
  - [func \(int \*DangerousInternalClient\) ParseBusinessProfile\(node \*waBinary.Node\) \(\*types.BusinessProfile, error\)](<#DangerousInternalClient.ParseBusinessProfile>)
  - [func \(int \*DangerousInternalClient\) ParseGroupChange\(node \*waBinary.Node\) \(\*events.GroupInfo, \[\]store.LIDMapping, error\)](<#DangerousInternalClient.ParseGroupChange>)
  - [func \(int \*DangerousInternalClient\) ParseGroupCreate\(parentNode, node \*waBinary.Node\) \(\*events.JoinedGroup, \[\]store.LIDMapping, \[\]store.RedactedPhoneEntry, error\)](<#DangerousInternalClient.ParseGroupCreate>)
  - [func \(int \*DangerousInternalClient\) ParseGroupNode\(groupNode \*waBinary.Node\) \(\*types.GroupInfo, error\)](<#DangerousInternalClient.ParseGroupNode>)
  - [func \(int \*DangerousInternalClient\) ParseGroupNotification\(node \*waBinary.Node\) \(any, \[\]store.LIDMapping, \[\]store.RedactedPhoneEntry, error\)](<#DangerousInternalClient.ParseGroupNotification>)
  - [func \(int \*DangerousInternalClient\) ParseMessageInfo\(node \*waBinary.Node\) \(\*types.MessageInfo, error\)](<#DangerousInternalClient.ParseMessageInfo>)
  - [func \(int \*DangerousInternalClient\) ParseMessageSource\(node \*waBinary.Node, requireParticipant bool\) \(source types.MessageSource, err error\)](<#DangerousInternalClient.ParseMessageSource>)
  - [func \(int \*DangerousInternalClient\) ParseMsgBotInfo\(node waBinary.Node\) \(botInfo types.MsgBotInfo, err error\)](<#DangerousInternalClient.ParseMsgBotInfo>)
  - [func \(int \*DangerousInternalClient\) ParseMsgMetaInfo\(node waBinary.Node\) \(metaInfo types.MsgMetaInfo, err error\)](<#DangerousInternalClient.ParseMsgMetaInfo>)
  - [func \(int \*DangerousInternalClient\) ParseNewsletterMessages\(node \*waBinary.Node\) \[\]\*types.NewsletterMessage](<#DangerousInternalClient.ParseNewsletterMessages>)
  - [func \(int \*DangerousInternalClient\) ParsePrivacySettings\(privacyNode \*waBinary.Node, settings \*types.PrivacySettings\) \*events.PrivacySettings](<#DangerousInternalClient.ParsePrivacySettings>)
  - [func \(int \*DangerousInternalClient\) ParseReceipt\(node \*waBinary.Node\) \(\*events.Receipt, error\)](<#DangerousInternalClient.ParseReceipt>)
  - [func \(int \*DangerousInternalClient\) PrepareMessageNode\(ctx context.Context, to types.JID, id types.MessageID, message \*waE2E.Message, participants \[\]types.JID, plaintext, dsmPlaintext \[\]byte, timings \*MessageDebugTimings, extraParams nodeExtraParams\) \(\*waBinary.Node, \[\]types.JID, error\)](<#DangerousInternalClient.PrepareMessageNode>)
  - [func \(int \*DangerousInternalClient\) PrepareMessageNodeV3\(ctx context.Context, to, ownID types.JID, id types.MessageID, payload \*waMsgTransport.MessageTransport\_Payload, skdm \*waMsgTransport.MessageTransport\_Protocol\_Ancillary\_SenderKeyDistributionMessage, msgAttrs messageAttrs, frankingTag \[\]byte, participants \[\]types.JID, timings \*MessageDebugTimings\) \(\*waBinary.Node, \[\]types.JID, error\)](<#DangerousInternalClient.PrepareMessageNodeV3>)
  - [func \(int \*DangerousInternalClient\) PreparePeerMessageNode\(ctx context.Context, to types.JID, id types.MessageID, message \*waE2E.Message, timings \*MessageDebugTimings\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.PreparePeerMessageNode>)
  - [func \(int \*DangerousInternalClient\) ProcessProtocolParts\(ctx context.Context, info \*types.MessageInfo, msg \*waE2E.Message\) \(ok bool\)](<#DangerousInternalClient.ProcessProtocolParts>)
  - [func \(int \*DangerousInternalClient\) QueryMediaConn\(ctx context.Context\) \(\*MediaConn, error\)](<#DangerousInternalClient.QueryMediaConn>)
  - [func \(int \*DangerousInternalClient\) RawUpload\(ctx context.Context, dataToUpload io.Reader, uploadSize uint64, fileHash \[\]byte, appInfo MediaType, newsletter bool, resp \*UploadResponse\) error](<#DangerousInternalClient.RawUpload>)
  - [func \(int \*DangerousInternalClient\) ReceiveResponse\(ctx context.Context, data \*waBinary.Node\) bool](<#DangerousInternalClient.ReceiveResponse>)
  - [func \(int \*DangerousInternalClient\) RefreshMediaConn\(ctx context.Context, force bool\) \(\*MediaConn, error\)](<#DangerousInternalClient.RefreshMediaConn>)
  - [func \(int \*DangerousInternalClient\) RequestAppStateKeys\(ctx context.Context, rawKeyIDs \[\]\[\]byte\)](<#DangerousInternalClient.RequestAppStateKeys>)
  - [func \(int \*DangerousInternalClient\) RequestMissingAppStateKeys\(ctx context.Context, patches \*appstate.PatchList\)](<#DangerousInternalClient.RequestMissingAppStateKeys>)
  - [func \(int \*DangerousInternalClient\) ResetExpectedDisconnect\(\)](<#DangerousInternalClient.ResetExpectedDisconnect>)
  - [func \(int \*DangerousInternalClient\) RetryFrame\(ctx context.Context, reqType, id string, data \[\]byte, origResp \*waBinary.Node, timeout time.Duration\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.RetryFrame>)
  - [func \(int \*DangerousInternalClient\) SendAck\(ctx context.Context, node \*waBinary.Node, error int\)](<#DangerousInternalClient.SendAck>)
  - [func \(int \*DangerousInternalClient\) SendAppState\(ctx context.Context, patch appstate.PatchInfo, allowRetry bool\) error](<#DangerousInternalClient.SendAppState>)
  - [func \(int \*DangerousInternalClient\) SendDM\(ctx context.Context, ownID, to types.JID, id types.MessageID, message \*waE2E.Message, timings \*MessageDebugTimings, extraParams nodeExtraParams\) \(string, \[\]byte, error\)](<#DangerousInternalClient.SendDM>)
  - [func \(int \*DangerousInternalClient\) SendDMV3\(ctx context.Context, to, ownID types.JID, id types.MessageID, messageApp \[\]byte, msgAttrs messageAttrs, frankingTag \[\]byte, timings \*MessageDebugTimings\) \(\[\]byte, string, error\)](<#DangerousInternalClient.SendDMV3>)
  - [func \(int \*DangerousInternalClient\) SendGroup\(ctx context.Context, ownID, to types.JID, participants \[\]types.JID, id types.MessageID, message \*waE2E.Message, timings \*MessageDebugTimings, extraParams nodeExtraParams\) \(string, \[\]byte, error\)](<#DangerousInternalClient.SendGroup>)
  - [func \(int \*DangerousInternalClient\) SendGroupIQ\(ctx context.Context, iqType infoQueryType, jid types.JID, content waBinary.Node\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.SendGroupIQ>)
  - [func \(int \*DangerousInternalClient\) SendGroupV3\(ctx context.Context, to, ownID types.JID, id types.MessageID, messageApp \[\]byte, msgAttrs messageAttrs, frankingTag \[\]byte, timings \*MessageDebugTimings\) \(string, \[\]byte, error\)](<#DangerousInternalClient.SendGroupV3>)
  - [func \(int \*DangerousInternalClient\) SendIQ\(ctx context.Context, query infoQuery\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.SendIQ>)
  - [func \(int \*DangerousInternalClient\) SendIQAsync\(ctx context.Context, query infoQuery\) \(\<\-chan \*waBinary.Node, error\)](<#DangerousInternalClient.SendIQAsync>)
  - [func \(int \*DangerousInternalClient\) SendIQAsyncAndGetData\(ctx context.Context, query \*infoQuery\) \(\<\-chan \*waBinary.Node, \[\]byte, error\)](<#DangerousInternalClient.SendIQAsyncAndGetData>)
  - [func \(int \*DangerousInternalClient\) SendKeepAlive\(ctx context.Context\) \(isSuccess, shouldContinue bool\)](<#DangerousInternalClient.SendKeepAlive>)
  - [func \(int \*DangerousInternalClient\) SendMessageReceipt\(ctx context.Context, info \*types.MessageInfo, node \*waBinary.Node\)](<#DangerousInternalClient.SendMessageReceipt>)
  - [func \(int \*DangerousInternalClient\) SendMexIQ\(ctx context.Context, queryID string, variables any\) \(json.RawMessage, error\)](<#DangerousInternalClient.SendMexIQ>)
  - [func \(int \*DangerousInternalClient\) SendNewsletter\(ctx context.Context, to types.JID, id types.MessageID, message \*waE2E.Message, mediaID string, timings \*MessageDebugTimings\) \(\[\]byte, error\)](<#DangerousInternalClient.SendNewsletter>)
  - [func \(int \*DangerousInternalClient\) SendNode\(ctx context.Context, node waBinary.Node\) error](<#DangerousInternalClient.SendNode>)
  - [func \(int \*DangerousInternalClient\) SendNodeAndGetData\(ctx context.Context, node waBinary.Node\) \(\[\]byte, error\)](<#DangerousInternalClient.SendNodeAndGetData>)
  - [func \(int \*DangerousInternalClient\) SendPairError\(ctx context.Context, id string, code int, text string\)](<#DangerousInternalClient.SendPairError>)
  - [func \(int \*DangerousInternalClient\) SendPeerMessage\(ctx context.Context, to types.JID, id types.MessageID, message \*waE2E.Message, timings \*MessageDebugTimings\) \(\[\]byte, error\)](<#DangerousInternalClient.SendPeerMessage>)
  - [func \(int \*DangerousInternalClient\) SendProtocolMessageReceipt\(ctx context.Context, id types.MessageID, msgType types.ReceiptType\)](<#DangerousInternalClient.SendProtocolMessageReceipt>)
  - [func \(int \*DangerousInternalClient\) SendRetryReceipt\(ctx context.Context, node \*waBinary.Node, info \*types.MessageInfo, forceIncludeIdentity bool\)](<#DangerousInternalClient.SendRetryReceipt>)
  - [func \(int \*DangerousInternalClient\) SetTransport\(transport \*http.Transport, opt SetProxyOptions\)](<#DangerousInternalClient.SetTransport>)
  - [func \(int \*DangerousInternalClient\) ShouldIncludeReportingToken\(message \*waE2E.Message\) bool](<#DangerousInternalClient.ShouldIncludeReportingToken>)
  - [func \(int \*DangerousInternalClient\) ShouldRecreateSession\(ctx context.Context, retryCount int, jid types.JID\) \(reason string, recreate bool\)](<#DangerousInternalClient.ShouldRecreateSession>)
  - [func \(int \*DangerousInternalClient\) StoreGlobalSettings\(ctx context.Context, settings \*waHistorySync.GlobalSettings\)](<#DangerousInternalClient.StoreGlobalSettings>)
  - [func \(int \*DangerousInternalClient\) StoreHistoricalMessageSecrets\(ctx context.Context, conversations \[\]\*waHistorySync.Conversation\)](<#DangerousInternalClient.StoreHistoricalMessageSecrets>)
  - [func \(int \*DangerousInternalClient\) StoreHistoricalPNLIDMappings\(ctx context.Context, mappings \[\]\*waHistorySync.PhoneNumberToLIDMapping\)](<#DangerousInternalClient.StoreHistoricalPNLIDMappings>)
  - [func \(int \*DangerousInternalClient\) StoreLIDSyncMessage\(ctx context.Context, msg \[\]byte\)](<#DangerousInternalClient.StoreLIDSyncMessage>)
  - [func \(int \*DangerousInternalClient\) StoreMessageSecret\(ctx context.Context, info \*types.MessageInfo, msg \*waE2E.Message\)](<#DangerousInternalClient.StoreMessageSecret>)
  - [func \(int \*DangerousInternalClient\) TryHandleCodePairNotification\(ctx context.Context, parentNode \*waBinary.Node\)](<#DangerousInternalClient.TryHandleCodePairNotification>)
  - [func \(int \*DangerousInternalClient\) UnlockedConnect\(ctx context.Context\) error](<#DangerousInternalClient.UnlockedConnect>)
  - [func \(int \*DangerousInternalClient\) UnlockedDisconnect\(\)](<#DangerousInternalClient.UnlockedDisconnect>)
  - [func \(int \*DangerousInternalClient\) UpdateBusinessName\(ctx context.Context, user, userAlt types.JID, messageInfo \*types.MessageInfo, name string\)](<#DangerousInternalClient.UpdateBusinessName>)
  - [func \(int \*DangerousInternalClient\) UpdateGroupParticipantCache\(evt \*events.GroupInfo\)](<#DangerousInternalClient.UpdateGroupParticipantCache>)
  - [func \(int \*DangerousInternalClient\) UpdatePushName\(ctx context.Context, user, userAlt types.JID, messageInfo \*types.MessageInfo, name string\)](<#DangerousInternalClient.UpdatePushName>)
  - [func \(int \*DangerousInternalClient\) UploadPreKeys\(ctx context.Context, initialUpload bool\)](<#DangerousInternalClient.UploadPreKeys>)
  - [func \(int \*DangerousInternalClient\) Usync\(ctx context.Context, jids \[\]types.JID, mode, context string, query \[\]waBinary.Node, extra ...UsyncQueryExtras\) \(\*waBinary.Node, error\)](<#DangerousInternalClient.Usync>)
  - [func \(int \*DangerousInternalClient\) WaitResponse\(reqID string\) chan \*waBinary.Node](<#DangerousInternalClient.WaitResponse>)
- [type DisconnectedError](<#DisconnectedError>)
  - [func \(err \*DisconnectedError\) Error\(\) string](<#DisconnectedError.Error>)
  - [func \(err \*DisconnectedError\) Is\(other error\) bool](<#DisconnectedError.Is>)
- [type DownloadHTTPError](<#DownloadHTTPError>)
  - [func \(dhe DownloadHTTPError\) Error\(\) string](<#DownloadHTTPError.Error>)
  - [func \(dhe DownloadHTTPError\) Is\(other error\) bool](<#DownloadHTTPError.Is>)
- [type DownloadableMessage](<#DownloadableMessage>)
- [type DownloadableThumbnail](<#DownloadableThumbnail>)
- [type ElementMissingError](<#ElementMissingError>)
  - [func \(eme \*ElementMissingError\) Error\(\) string](<#ElementMissingError.Error>)
- [type EventHandler](<#EventHandler>)
- [type EventHandlerWithSuccessStatus](<#EventHandlerWithSuccessStatus>)
- [type FCMPushConfig](<#FCMPushConfig>)
  - [func \(fpc \*FCMPushConfig\) GetPushConfigAttrs\(\) waBinary.Attrs](<#FCMPushConfig.GetPushConfigAttrs>)
- [type File](<#File>)
- [type GetNewsletterMessagesParams](<#GetNewsletterMessagesParams>)
- [type GetNewsletterUpdatesParams](<#GetNewsletterUpdatesParams>)
- [type GetProfilePictureParams](<#GetProfilePictureParams>)
- [type IQError](<#IQError>)
  - [func \(iqe \*IQError\) Error\(\) string](<#IQError.Error>)
  - [func \(iqe \*IQError\) Is\(other error\) bool](<#IQError.Is>)
- [type MediaConn](<#MediaConn>)
  - [func \(mc \*MediaConn\) Expiry\(\) time.Time](<#MediaConn.Expiry>)
- [type MediaConnHost](<#MediaConnHost>)
- [type MediaType](<#MediaType>)
  - [func GetMediaType\(msg DownloadableMessage\) MediaType](<#GetMediaType>)
- [type MediaTypeable](<#MediaTypeable>)
- [type MessageDebugTimings](<#MessageDebugTimings>)
  - [func \(mdt MessageDebugTimings\) MarshalZerologObject\(evt \*zerolog.Event\)](<#MessageDebugTimings.MarshalZerologObject>)
- [type MessengerConfig](<#MessengerConfig>)
- [type MsgSecretType](<#MsgSecretType>)
- [type PairClientType](<#PairClientType>)
- [type PairDatabaseError](<#PairDatabaseError>)
  - [func \(err \*PairDatabaseError\) Error\(\) string](<#PairDatabaseError.Error>)
  - [func \(err \*PairDatabaseError\) Unwrap\(\) error](<#PairDatabaseError.Unwrap>)
- [type PairProtoError](<#PairProtoError>)
  - [func \(err \*PairProtoError\) Error\(\) string](<#PairProtoError.Error>)
  - [func \(err \*PairProtoError\) Unwrap\(\) error](<#PairProtoError.Unwrap>)
- [type ParticipantChange](<#ParticipantChange>)
- [type ParticipantRequestChange](<#ParticipantRequestChange>)
- [type Proxy](<#Proxy>)
- [type PushConfig](<#PushConfig>)
- [type QRChannelItem](<#QRChannelItem>)
- [type RecentMessage](<#RecentMessage>)
  - [func \(rm RecentMessage\) IsEmpty\(\) bool](<#RecentMessage.IsEmpty>)
- [type ReqCreateGroup](<#ReqCreateGroup>)
- [type SendRequestExtra](<#SendRequestExtra>)
- [type SendResponse](<#SendResponse>)
- [type SetProxyOptions](<#SetProxyOptions>)
- [type UploadResponse](<#UploadResponse>)
- [type UsyncQueryExtras](<#UsyncQueryExtras>)
- [type WebPushConfig](<#WebPushConfig>)
  - [func \(wpc \*WebPushConfig\) GetPushConfigAttrs\(\) waBinary.Attrs](<#WebPushConfig.GetPushConfigAttrs>)


## Constants

<a name="WantedPreKeyCount"></a>

```go
const (
    // WantedPreKeyCount is the number of prekeys that the client should upload to the WhatsApp servers in a single batch.
    WantedPreKeyCount = 50
    // MinPreKeyCount is the number of prekeys when the client will upload a new batch of prekeys to the WhatsApp servers.
    MinPreKeyCount = 5
)
```

<a name="NackParsingError"></a>

```go
const (
    NackParsingError                 = 487
    NackUnrecognizedStanza           = 488
    NackUnrecognizedStanzaClass      = 489
    NackUnrecognizedStanzaType       = 490
    NackInvalidProtobuf              = 491
    NackInvalidHostedCompanionStanza = 493
    NackMissingMessageSecret         = 495
    NackSignalErrorOldCounter        = 496
    NackMessageDeletedOnPeer         = 499
    NackUnhandledError               = 500
    NackUnsupportedAdminRevoke       = 550
    NackUnsupportedLIDGroup          = 551
    NackDBOperationFailed            = 552
)
```

<a name="DisappearingTimerOff"></a>

```go
const (
    DisappearingTimerOff     = time.Duration(0)
    DisappearingTimer24Hours = 24 * time.Hour
    DisappearingTimer7Days   = 7 * 24 * time.Hour
    DisappearingTimer90Days  = 90 * 24 * time.Hour
)
```

<a name="BusinessMessageLinkPrefix"></a>

```go
const (
    BusinessMessageLinkPrefix       = "https://wa.me/message/"
    ContactQRLinkPrefix             = "https://wa.me/qr/"
    BusinessMessageLinkDirectPrefix = "https://api.whatsapp.com/message/"
    ContactQRLinkDirectPrefix       = "https://api.whatsapp.com/qr/"
    NewsletterLinkPrefix            = "https://whatsapp.com/channel/"
)
```

<a name="EditWindow"></a>EditWindow specifies how long a message can be edited for after it was sent.

```go
const EditWindow = 20 * time.Minute
```

<a name="FBArmadilloMessageVersion"></a>

```go
const FBArmadilloMessageVersion = 1
```

<a name="FBConsumerMessageVersion"></a>

```go
const FBConsumerMessageVersion = 1
```

<a name="FBMessageApplicationVersion"></a>

```go
const FBMessageApplicationVersion = 2
```

<a name="FBMessageVersion"></a>

```go
const FBMessageVersion = 3
```

<a name="IGMessageApplicationVersion"></a>

```go
const IGMessageApplicationVersion = 3
```

<a name="InviteLinkPrefix"></a>

```go
const InviteLinkPrefix = "https://chat.whatsapp.com/"
```

<a name="NoiseHandshakeResponseTimeout"></a>

```go
const NoiseHandshakeResponseTimeout = 20 * time.Second
```

<a name="QRChannelEventCode"></a>

```go
const QRChannelEventCode = "code"
```

<a name="QRChannelEventError"></a>

```go
const QRChannelEventError = "error"
```

<a name="RemoveReactionText"></a>

```go
const RemoveReactionText = ""
```

<a name="WACertIssuerSerial"></a>

```go
const WACertIssuerSerial = 0
```

<a name="WebMessageIDPrefix"></a>

```go
const WebMessageIDPrefix = "3EB0"
```

## Variables

<a name="ErrClientIsNil"></a>Miscellaneous errors

```go
var (
    ErrClientIsNil     = errors.New("client is nil")
    ErrNoSession       = errors.New("can't encrypt message for device: no signal session established")
    ErrIQTimedOut      = errors.New("info query timed out")
    ErrNotConnected    = errors.New("websocket not connected")
    ErrNotLoggedIn     = errors.New("the store doesn't contain a device JID")
    ErrMessageTimedOut = errors.New("timed out waiting for message send response")

    ErrAlreadyConnected = errors.New("websocket is already connected")

    ErrPhoneNumberTooShort           = errors.New("phone number too short")
    ErrPhoneNumberIsNotInternational = errors.New("international phone number required (must not start with 0)")

    ErrQRAlreadyConnected = errors.New("GetQRChannel must be called before connecting")
    ErrQRStoreContainsID  = errors.New("GetQRChannel can only be called when there's no user ID in the client's Store")

    ErrNoPushName = errors.New("can't send presence without PushName set")

    ErrNoPrivacyToken = errors.New("no privacy token stored")

    ErrAppStateUpdate = errors.New("server returned error updating app state")
)
```

<a name="ErrPairInvalidDeviceIdentityHMAC"></a>Errors that happen while confirming device pairing

```go
var (
    ErrPairInvalidDeviceIdentityHMAC = errors.New("invalid device identity HMAC in pair success message")
    ErrPairInvalidDeviceSignature    = errors.New("invalid device signature in pair success message")
    ErrPairRejectedLocally           = errors.New("local PrePairCallback rejected pairing")
)
```

<a name="ErrProfilePictureUnauthorized"></a>

```go
var (
    // ErrProfilePictureUnauthorized is returned by GetProfilePictureInfo when trying to get the profile picture of a user
    // whose privacy settings prevent you from seeing their profile picture (status code 401).
    ErrProfilePictureUnauthorized = errors.New("the user has hidden their profile picture from you")
    // ErrProfilePictureNotSet is returned by GetProfilePictureInfo when the given user or group doesn't have a profile
    // picture (status code 404).
    ErrProfilePictureNotSet = errors.New("that user or group does not have a profile picture")
    // ErrGroupInviteLinkUnauthorized is returned by GetGroupInviteLink if you don't have the permission to get the link (status code 401).
    ErrGroupInviteLinkUnauthorized = errors.New("you don't have the permission to get the group's invite link")
    // ErrNotInGroup is returned by group info getting methods if you're not in the group (status code 403).
    ErrNotInGroup = errors.New("you're not participating in that group")
    // ErrGroupNotFound is returned by group info getting methods if the group doesn't exist (status code 404).
    ErrGroupNotFound = errors.New("that group does not exist")
    // ErrInviteLinkInvalid is returned by methods that use group invite links if the invite link is malformed.
    ErrInviteLinkInvalid = errors.New("that group invite link is not valid")
    // ErrInviteLinkRevoked is returned by methods that use group invite links if the invite link was valid, but has been revoked and can no longer be used.
    ErrInviteLinkRevoked = errors.New("that group invite link has been revoked")
    // ErrBusinessMessageLinkNotFound is returned by ResolveBusinessMessageLink if the link doesn't exist or has been revoked.
    ErrBusinessMessageLinkNotFound = errors.New("that business message link does not exist or has been revoked")
    // ErrContactQRLinkNotFound is returned by ResolveContactQRLink if the link doesn't exist or has been revoked.
    ErrContactQRLinkNotFound = errors.New("that contact QR link does not exist or has been revoked")
    // ErrInvalidImageFormat is returned by SetGroupPhoto if the given photo is not in the correct format.
    ErrInvalidImageFormat = errors.New("the given data is not a valid image")
    // ErrMediaNotAvailableOnPhone is returned by DecryptMediaRetryNotification if the given event contains error code 2.
    ErrMediaNotAvailableOnPhone = errors.New("media no longer available on phone")
    // ErrUnknownMediaRetryError is returned by DecryptMediaRetryNotification if the given event contains an unknown error code.
    ErrUnknownMediaRetryError = errors.New("unknown media retry error")
    // ErrInvalidDisappearingTimer is returned by SetDisappearingTimer if the given timer is not one of the allowed values.
    ErrInvalidDisappearingTimer = errors.New("invalid disappearing timer provided")
)
```

<a name="ErrBroadcastListUnsupported"></a>Some errors that Client.SendMessage can return

```go
var (
    ErrBroadcastListUnsupported = errors.New("sending to non-status broadcast lists is not yet supported")
    ErrUnknownServer            = errors.New("can't send message to unknown server")
    ErrRecipientADJID           = errors.New("message recipient must be a user JID with no device part")
    ErrServerReturnedError      = errors.New("server returned error")
    ErrInvalidInlineBotID       = errors.New("invalid inline bot ID")
)
```

<a name="ErrMediaDownloadFailedWith403"></a>Some errors that Client.Download can return

```go
var (
    ErrMediaDownloadFailedWith403 = DownloadHTTPError{Response: &http.Response{StatusCode: 403}}
    ErrMediaDownloadFailedWith404 = DownloadHTTPError{Response: &http.Response{StatusCode: 404}}
    ErrMediaDownloadFailedWith410 = DownloadHTTPError{Response: &http.Response{StatusCode: 410}}
    ErrNoURLPresent               = errors.New("no url present")
    ErrFileLengthMismatch         = errors.New("file length does not match")
    ErrTooShortFile               = errors.New("file too short")
    ErrInvalidMediaHMAC           = errors.New("invalid media hmac")
    ErrInvalidMediaEncSHA256      = errors.New("hash of media ciphertext doesn't match")
    ErrInvalidMediaSHA256         = errors.New("hash of media plaintext doesn't match")
    ErrUnknownMediaType           = errors.New("unknown media type")
    ErrNothingDownloadableFound   = errors.New("didn't find any attachments in message")
)
```

<a name="ErrOriginalMessageSecretNotFound"></a>

```go
var (
    ErrOriginalMessageSecretNotFound = errors.New("original message secret key not found")
    ErrNotEncryptedReactionMessage   = errors.New("given message isn't an encrypted reaction message")
    ErrNotEncryptedCommentMessage    = errors.New("given message isn't an encrypted comment message")
    ErrNotSecretEncryptedMessage     = errors.New("given message isn't a secret encrypted message")
    ErrNotPollUpdateMessage          = errors.New("given message isn't a poll update message")
)
```

<a name="ErrIQBadRequest"></a>Common errors returned by info queries for use with errors.Is

```go
var (
    ErrIQBadRequest          error = &IQError{Code: 400, Text: "bad-request"}
    ErrIQNotAuthorized       error = &IQError{Code: 401, Text: "not-authorized"}
    ErrIQForbidden           error = &IQError{Code: 403, Text: "forbidden"}
    ErrIQNotFound            error = &IQError{Code: 404, Text: "item-not-found"}
    ErrIQNotAllowed          error = &IQError{Code: 405, Text: "not-allowed"}
    ErrIQNotAcceptable       error = &IQError{Code: 406, Text: "not-acceptable"}
    ErrIQGone                error = &IQError{Code: 410, Text: "gone"}
    ErrIQResourceLimit       error = &IQError{Code: 419, Text: "resource-limit"}
    ErrIQLocked              error = &IQError{Code: 423, Text: "locked"}
    ErrIQRateOverLimit       error = &IQError{Code: 429, Text: "rate-overlimit"}
    ErrIQInternalServerError error = &IQError{Code: 500, Text: "internal-server-error"}
    ErrIQServiceUnavailable  error = &IQError{Code: 503, Text: "service-unavailable"}
    ErrIQPartialServerError  error = &IQError{Code: 530, Text: "partial-server-error"}
)
```

<a name="KeepAliveResponseDeadline"></a>

```go
var (
    // KeepAliveResponseDeadline specifies the duration to wait for a response to websocket keepalive pings.
    KeepAliveResponseDeadline = 10 * time.Second
    // KeepAliveIntervalMin specifies the minimum interval for websocket keepalive pings.
    KeepAliveIntervalMin = 20 * time.Second
    // KeepAliveIntervalMax specifies the maximum interval for websocket keepalive pings.
    KeepAliveIntervalMax = 30 * time.Second

    // KeepAliveMaxFailTime specifies the maximum time to wait before forcing a reconnect if keepalives fail repeatedly.
    KeepAliveMaxFailTime = 3 * time.Minute
)
```

<a name="AdvAccountSignaturePrefix"></a>

```go
var (
    AdvAccountSignaturePrefix = []byte{6, 0}
    AdvDeviceSignaturePrefix  = []byte{6, 1}

    AdvHostedAccountSignaturePrefix = []byte{6, 5}
    AdvHostedDeviceSignaturePrefix  = []byte{6, 6}
)
```

<a name="QRChannelSuccess"></a>Possible final items in the QR channel. In addition to these, an \`error\` event may be emitted, in which case the Error field will have the error that occurred during pairing.

```go
var (
    // QRChannelSuccess is emitted from GetQRChannel when the pairing is successful.
    QRChannelSuccess = QRChannelItem{Event: "success"}
    // QRChannelTimeout is emitted from GetQRChannel if the socket gets disconnected by the server before the pairing is successful.
    QRChannelTimeout = QRChannelItem{Event: "timeout"}
    // QRChannelErrUnexpectedEvent is emitted from GetQRChannel if an unexpected connection event is received,
    // as that likely means that the pairing has already happened before the channel was set up.
    QRChannelErrUnexpectedEvent = QRChannelItem{Event: "err-unexpected-state"}
    // QRChannelClientOutdated is emitted from GetQRChannel if events.ClientOutdated is received.
    QRChannelClientOutdated = QRChannelItem{Event: "err-client-outdated"}
    // QRChannelScannedWithoutMultidevice is emitted from GetQRChannel if events.QRScannedWithoutMultidevice is received.
    QRChannelScannedWithoutMultidevice = QRChannelItem{Event: "err-scanned-without-multidevice"}
)
```

<a name="DefaultStatusPrivacy"></a>

```go
var DefaultStatusPrivacy = []types.StatusPrivacy{{
    Type:      types.StatusPrivacyTypeContacts,
    IsDefault: true,
}}
```

<a name="ErrIQDisconnected"></a>

```go
var ErrIQDisconnected = &DisconnectedError{Action: "info query"}
```

<a name="EventAlreadyProcessed"></a>

```go
var EventAlreadyProcessed = errors.New("event was already processed")
```

<a name="RequestFromPhoneDelay"></a>RequestFromPhoneDelay specifies how long to wait for the sender to resend the message before requesting from your phone. This is only used if Client.AutomaticMessageRerequestFromPhone is true.

```go
var RequestFromPhoneDelay = 5 * time.Second
```

<a name="ReturnDownloadWarnings"></a>ReturnDownloadWarnings controls whether the Download function returns non\-fatal validation warnings. Currently, these include [ErrFileLengthMismatch](<#ErrMediaDownloadFailedWith403>) and [ErrInvalidMediaSHA256](<#ErrMediaDownloadFailedWith403>).

```go
var ReturnDownloadWarnings = true
```

<a name="WACertPubKey"></a>

```go
var WACertPubKey = [...]byte{0x14, 0x23, 0x75, 0x57, 0x4d, 0xa, 0x58, 0x71, 0x66, 0xaa, 0xe7, 0x1e, 0xbe, 0x51, 0x64, 0x37, 0xc4, 0xa2, 0x8b, 0x73, 0xe3, 0x69, 0x5c, 0x6c, 0xe1, 0xf7, 0xf9, 0x54, 0x5d, 0xa8, 0xee, 0x6b}
```

<a name="DecryptMediaRetryNotification"></a>
## func DecryptMediaRetryNotification

```go
func DecryptMediaRetryNotification(evt *events.MediaRetry, mediaKey []byte) (*waMmsRetry.MediaRetryNotification, error)
```

DecryptMediaRetryNotification decrypts a media retry notification using the media key. See Client.SendMediaRetryReceipt for more info on how to use this.

<a name="GenerateFacebookMessageID"></a>
## func GenerateFacebookMessageID

```go
func GenerateFacebookMessageID() int64
```



<a name="GenerateMessageID"></a>
## func GenerateMessageID

```go
func GenerateMessageID() types.MessageID
```

GenerateMessageID generates a random string that can be used as a message ID on WhatsApp.

```
msgID := whatsmeow.GenerateMessageID()
cli.SendMessage(context.Background(), targetJID, &waE2E.Message{...}, whatsmeow.SendRequestExtra{ID: msgID})
```

Deprecated: WhatsApp web has switched to using a hash of the current timestamp, user id and random bytes. Use Client.GenerateMessageID instead.

<a name="GetLatestVersion"></a>
## func GetLatestVersion

```go
func GetLatestVersion(ctx context.Context, httpClient *http.Client) (*store.WAVersionContainer, error)
```

GetLatestVersion returns the latest version number from web.whatsapp.com.

After fetching, you can update the version to use using store.SetWAVersion, e.g.

```
latestVer, err := GetLatestVersion(nil)
if err != nil {
	return err
}
store.SetWAVersion(*latestVer)
```

<a name="HashPollOptions"></a>
## func HashPollOptions

```go
func HashPollOptions(optionNames []string) [][]byte
```

HashPollOptions hashes poll option names using SHA\-256 for voting. This is used by BuildPollVote to convert selected option names to hashes.

<a name="ParseDisappearingTimerString"></a>
## func ParseDisappearingTimerString

```go
func ParseDisappearingTimerString(val string) (time.Duration, bool)
```

ParseDisappearingTimerString parses common human\-readable disappearing message timer strings into Duration values. If the string doesn't look like one of the allowed values \(0, 24h, 7d, 90d\), the second return value is false.

<a name="APNsPushConfig"></a>
## type APNsPushConfig



```go
type APNsPushConfig struct {
    Token       string `json:"token"`
    VoIPToken   string `json:"voip_token"`
    MsgIDEncKey []byte `json:"msg_id_enc_key"`
}
```

<a name="APNsPushConfig.GetPushConfigAttrs"></a>
### func \(\*APNsPushConfig\) GetPushConfigAttrs

```go
func (apc *APNsPushConfig) GetPushConfigAttrs() waBinary.Attrs
```



<a name="Client"></a>
## type Client

Client contains everything necessary to connect to and interact with the WhatsApp web API.

```go
type Client struct {
    Store *store.Device
    Log   waLog.Logger

    EnableAutoReconnect   bool
    InitialAutoReconnect  bool
    LastSuccessfulConnect time.Time
    AutoReconnectErrors   int
    // AutoReconnectHook is called when auto-reconnection fails. If the function returns false,
    // the client will not attempt to reconnect. The number of retries can be read from AutoReconnectErrors.
    AutoReconnectHook func(error) bool
    // If SynchronousAck is set, acks for messages will only be sent after all event handlers return.
    SynchronousAck             bool
    EnableDecryptedEventBuffer bool

    DisableLoginAutoReconnect bool

    // EmitAppStateEventsOnFullSync can be set to true if you want to get app state events emitted
    // even when re-syncing the whole state.
    EmitAppStateEventsOnFullSync bool

    AutomaticMessageRerequestFromPhone bool

    ManualHistorySyncDownload bool

    // GetMessageForRetry is used to find the source message for handling retry receipts
    // when the message is not found in the recently sent message cache.
    GetMessageForRetry func(requester, to types.JID, id types.MessageID) *waE2E.Message
    // PreRetryCallback is called before a retry receipt is accepted.
    // If it returns false, the accepting will be cancelled and the retry receipt will be ignored.
    PreRetryCallback func(receipt *events.Receipt, id types.MessageID, retryCount int, msg *waE2E.Message) bool

    // PrePairCallback is called before pairing is completed. If it returns false, the pairing will be cancelled and
    // the client will disconnect.
    PrePairCallback func(jid types.JID, platform, businessName string) bool

    // GetClientPayload is called to get the client payload for connecting to the server.
    // This should NOT be used for WhatsApp (to change the OS name, update fields in store.BaseClientPayload directly).
    GetClientPayload func() *waWa6.ClientPayload

    // Should untrusted identity errors be handled automatically? If true, the stored identity and existing signal
    // sessions will be removed on untrusted identity errors, and an events.IdentityChange will be dispatched.
    // If false, decrypting a message from untrusted devices will fail.
    AutoTrustIdentity bool

    // Should SubscribePresence return an error if no privacy token is stored for the user?
    ErrorOnSubscribePresenceWithoutToken bool

    SendReportingTokens bool

    BackgroundEventCtx context.Context

    // This field changes the client to act like a Messenger client instead of a WhatsApp one.
    //
    // Note that you cannot use a Messenger account just by setting this field, you must use a
    // separate library for all the non-e2ee-related stuff like logging in.
    // The library is currently embedded in mautrix-meta (https://github.com/mautrix/meta), but may be separated later.
    MessengerConfig *MessengerConfig
    RefreshCAT      func(context.Context) error
    // contains filtered or unexported fields
}
```

<a name="NewClient"></a>
### func NewClient

```go
func NewClient(deviceStore *store.Device, log waLog.Logger) *Client
```

NewClient initializes a new WhatsApp web client.

The logger can be nil, it will default to a no\-op logger.

The device store must be set. A default SQL\-backed implementation is available in the store/sqlstore package.

```
container, err := sqlstore.New("sqlite3", "file:yoursqlitefile.db?_foreign_keys=on", nil)
if err != nil {
	panic(err)
}
// If you want multiple sessions, remember their JIDs and use .GetDevice(jid) or .GetAllDevices() instead.
deviceStore, err := container.GetFirstDevice()
if err != nil {
	panic(err)
}
client := whatsmeow.NewClient(deviceStore, nil)
```

<a name="Client.AcceptTOSNotice"></a>
### func \(\*Client\) AcceptTOSNotice

```go
func (cli *Client) AcceptTOSNotice(ctx context.Context, noticeID, stage string) error
```

AcceptTOSNotice accepts a ToS notice.

To accept the terms for creating newsletters, use

```
cli.AcceptTOSNotice("20601218", "5")
```

<a name="Client.AddEventHandler"></a>
### func \(\*Client\) AddEventHandler

```go
func (cli *Client) AddEventHandler(handler EventHandler) uint32
```

AddEventHandler registers a new function to receive all events emitted by this client.

The returned integer is the event handler ID, which can be passed to RemoveEventHandler to remove it.

All registered event handlers will receive all events. You should use a type switch statement to filter the events you want:

```
func myEventHandler(evt interface{}) {
	switch v := evt.(type) {
	case *events.Message:
		fmt.Println("Received a message!")
	case *events.Receipt:
		fmt.Println("Received a receipt!")
	}
}
```

If you want to access the Client instance inside the event handler, the recommended way is to wrap the whole handler in another struct:

```
type MyClient struct {
	WAClient *whatsmeow.Client
	eventHandlerID uint32
}

func (mycli *MyClient) register() {
	mycli.eventHandlerID = mycli.WAClient.AddEventHandler(mycli.myEventHandler)
}

func (mycli *MyClient) myEventHandler(evt interface{}) {
	// Handle event and access mycli.WAClient
}
```

<a name="Client.AddEventHandlerWithSuccessStatus"></a>
### func \(\*Client\) AddEventHandlerWithSuccessStatus

```go
func (cli *Client) AddEventHandlerWithSuccessStatus(handler EventHandlerWithSuccessStatus) uint32
```



<a name="Client.BuildEdit"></a>
### func \(\*Client\) BuildEdit

```go
func (cli *Client) BuildEdit(chat types.JID, id types.MessageID, newContent *waE2E.Message) *waE2E.Message
```

BuildEdit builds a message edit message using the given variables. The built message can be sent normally using Client.SendMessage.

```
resp, err := cli.SendMessage(context.Background(), chat, cli.BuildEdit(chat, originalMessageID, &waE2E.Message{
	Conversation: proto.String("edited message"),
})
```

<a name="Client.BuildHistorySyncRequest"></a>
### func \(\*Client\) BuildHistorySyncRequest

```go
func (cli *Client) BuildHistorySyncRequest(lastKnownMessageInfo *types.MessageInfo, count int) *waE2E.Message
```

BuildHistorySyncRequest builds a message to request additional history from the user's primary device.

The built message can be sent using Client.SendMessage, but you must pass whatsmeow.SendRequestExtra\{Peer: true\} as the last parameter. The response will come as an \*events.HistorySync with type \`ON\_DEMAND\`.

The response will contain to \`count\` messages immediately before the given message. The recommended number of messages to request at a time is 50.

<a name="Client.BuildMessageKey"></a>
### func \(\*Client\) BuildMessageKey

```go
func (cli *Client) BuildMessageKey(chat, sender types.JID, id types.MessageID) *waCommon.MessageKey
```

BuildMessageKey builds a MessageKey object, which is used to refer to previous messages for things such as replies, revocations and reactions.

<a name="Client.BuildPollCreation"></a>
### func \(\*Client\) BuildPollCreation

```go
func (cli *Client) BuildPollCreation(name string, optionNames []string, selectableOptionCount int) *waE2E.Message
```

BuildPollCreation builds a poll creation message with the given poll name, options and maximum number of selections. The built message can be sent normally using Client.SendMessage.

```
resp, err := cli.SendMessage(context.Background(), chat, cli.BuildPollCreation("meow?", []string{"yes", "no"}, 1))
```

<a name="Client.BuildPollVote"></a>
### func \(\*Client\) BuildPollVote

```go
func (cli *Client) BuildPollVote(ctx context.Context, pollInfo *types.MessageInfo, optionNames []string) (*waE2E.Message, error)
```

BuildPollVote builds a poll vote message using the given poll message info and option names. The built message can be sent normally using Client.SendMessage.

For example, to vote for the first option after receiving a message event \(\*events.Message\):

```
if evt.Message.GetPollCreationMessage() != nil {
	pollVoteMsg, err := cli.BuildPollVote(&evt.Info, []string{evt.Message.GetPollCreationMessage().GetOptions()[0].GetOptionName()})
	if err != nil {
		fmt.Println(":(", err)
		return
	}
	resp, err := cli.SendMessage(context.Background(), evt.Info.Chat, pollVoteMsg)
}
```

<a name="Client.BuildReaction"></a>
### func \(\*Client\) BuildReaction

```go
func (cli *Client) BuildReaction(chat, sender types.JID, id types.MessageID, reaction string) *waE2E.Message
```

BuildReaction builds a message reaction message using the given variables. The built message can be sent normally using Client.SendMessage.

```
resp, err := cli.SendMessage(context.Background(), chat, cli.BuildReaction(chat, senderJID, targetMessageID, "")
```

Note that for newsletter messages, you need to use NewsletterSendReaction instead of BuildReaction \+ SendMessage.

<a name="Client.BuildRevoke"></a>
### func \(\*Client\) BuildRevoke

```go
func (cli *Client) BuildRevoke(chat, sender types.JID, id types.MessageID) *waE2E.Message
```

BuildRevoke builds a message revocation message using the given variables. The built message can be sent normally using Client.SendMessage.

To revoke your own messages, pass your JID or an empty JID as the second parameter \(sender\).

```
resp, err := cli.SendMessage(context.Background(), chat, cli.BuildRevoke(chat, types.EmptyJID, originalMessageID)
```

To revoke someone else's messages when you are group admin, pass the message sender's JID as the second parameter.

```
resp, err := cli.SendMessage(context.Background(), chat, cli.BuildRevoke(chat, senderJID, originalMessageID)
```

<a name="Client.BuildUnavailableMessageRequest"></a>
### func \(\*Client\) BuildUnavailableMessageRequest

```go
func (cli *Client) BuildUnavailableMessageRequest(chat, sender types.JID, id string) *waE2E.Message
```

BuildUnavailableMessageRequest builds a message to request the user's primary device to send the copy of a message that this client was unable to decrypt.

The built message can be sent using Client.SendMessage, but you must pass whatsmeow.SendRequestExtra\{Peer: true\} as the last parameter. The full response will come as a ProtocolMessage with type \`PEER\_DATA\_OPERATION\_REQUEST\_RESPONSE\_MESSAGE\`. The response events will also be dispatched as normal \*events.Message's with UnavailableRequestID set to the request message ID.

<a name="Client.Connect"></a>
### func \(\*Client\) Connect

```go
func (cli *Client) Connect() error
```

Connect connects the client to the WhatsApp web websocket. After connection, it will either authenticate if there's data in the device store, or emit a QREvent to set up a new link.

<a name="Client.ConnectContext"></a>
### func \(\*Client\) ConnectContext

```go
func (cli *Client) ConnectContext(ctx context.Context) error
```



<a name="Client.CreateGroup"></a>
### func \(\*Client\) CreateGroup

```go
func (cli *Client) CreateGroup(ctx context.Context, req ReqCreateGroup) (*types.GroupInfo, error)
```

CreateGroup creates a group on WhatsApp with the given name and participants.

See ReqCreateGroup for parameters.

<a name="Client.CreateNewsletter"></a>
### func \(\*Client\) CreateNewsletter

```go
func (cli *Client) CreateNewsletter(ctx context.Context, params CreateNewsletterParams) (*types.NewsletterMetadata, error)
```

CreateNewsletter creates a new WhatsApp channel.

<a name="Client.DangerousInternals"></a>
### func \(\*Client\) DangerousInternals

```go
func (cli *Client) DangerousInternals() *DangerousInternalClient
```

DangerousInternals allows access to all unexported methods in Client.

Deprecated: dangerous

<a name="Client.DecryptComment"></a>
### func \(\*Client\) DecryptComment

```go
func (cli *Client) DecryptComment(ctx context.Context, comment *events.Message) (*waE2E.Message, error)
```

DecryptComment decrypts a reply/comment message in a community announcement group.

```
if evt.Message.GetEncCommentMessage() != nil {
	comment, err := cli.DecryptComment(evt)
	if err != nil {
		fmt.Println(":(", err)
		return
	}
	fmt.Printf("Comment message: %+v\n", comment)
}
```

<a name="Client.DecryptPollVote"></a>
### func \(\*Client\) DecryptPollVote

```go
func (cli *Client) DecryptPollVote(ctx context.Context, vote *events.Message) (*waE2E.PollVoteMessage, error)
```

DecryptPollVote decrypts a poll update message. The vote itself includes SHA\-256 hashes of the selected options.

```
if evt.Message.GetPollUpdateMessage() != nil {
	pollVote, err := cli.DecryptPollVote(evt)
	if err != nil {
		fmt.Println(":(", err)
		return
	}
	fmt.Println("Selected hashes:")
	for _, hash := range pollVote.GetSelectedOptions() {
		fmt.Printf("- %X\n", hash)
	}
}
```

<a name="Client.DecryptReaction"></a>
### func \(\*Client\) DecryptReaction

```go
func (cli *Client) DecryptReaction(ctx context.Context, reaction *events.Message) (*waE2E.ReactionMessage, error)
```

DecryptReaction decrypts a reaction message in a community announcement group.

```
if evt.Message.GetEncReactionMessage() != nil {
	reaction, err := cli.DecryptReaction(evt)
	if err != nil {
		fmt.Println(":(", err)
		return
	}
	fmt.Printf("Reaction message: %+v\n", reaction)
}
```

<a name="Client.DecryptSecretEncryptedMessage"></a>
### func \(\*Client\) DecryptSecretEncryptedMessage

```go
func (cli *Client) DecryptSecretEncryptedMessage(ctx context.Context, evt *events.Message) (*waE2E.Message, error)
```



<a name="Client.Disconnect"></a>
### func \(\*Client\) Disconnect

```go
func (cli *Client) Disconnect()
```

Disconnect disconnects from the WhatsApp web websocket.

This will not emit any events, the Disconnected event is only used when the connection is closed by the server or a network error.

<a name="Client.Download"></a>
### func \(\*Client\) Download

```go
func (cli *Client) Download(ctx context.Context, msg DownloadableMessage) ([]byte, error)
```

Download downloads the attachment from the given protobuf message.

The attachment is a specific part of a Message protobuf struct, not the message itself, e.g.

```
var msg *waE2E.Message
...
imageData, err := cli.Download(msg.GetImageMessage())
```

You can also use DownloadAny to download the first non\-nil sub\-message.

<a name="Client.DownloadAny"></a>
### func \(\*Client\) DownloadAny

```go
func (cli *Client) DownloadAny(ctx context.Context, msg *waE2E.Message) (data []byte, err error)
```

DownloadAny loops through the downloadable parts of the given message and downloads the first non\-nil item.

Deprecated: it's recommended to find the specific message type you want to download manually and use the Download method instead.

<a name="Client.DownloadFB"></a>
### func \(\*Client\) DownloadFB

```go
func (cli *Client) DownloadFB(ctx context.Context, transport *waMediaTransport.WAMediaTransport_Integral, mediaType MediaType) ([]byte, error)
```



<a name="Client.DownloadFBToFile"></a>
### func \(\*Client\) DownloadFBToFile

```go
func (cli *Client) DownloadFBToFile(ctx context.Context, transport *waMediaTransport.WAMediaTransport_Integral, mediaType MediaType, file File) error
```



<a name="Client.DownloadHistorySync"></a>
### func \(\*Client\) DownloadHistorySync

```go
func (cli *Client) DownloadHistorySync(ctx context.Context, notif *waE2E.HistorySyncNotification, synchronousStorage bool) (*waHistorySync.HistorySync, error)
```

DownloadHistorySync will download and parse the history sync blob from the given history sync notification.

You only need to call this manually if you set \[Client.ManualHistorySyncDownload\] to true. By default, whatsmeow will call this automatically and dispatch an \[events.HistorySync\] with the parsed data.

<a name="Client.DownloadMediaWithPath"></a>
### func \(\*Client\) DownloadMediaWithPath

```go
func (cli *Client) DownloadMediaWithPath(ctx context.Context, directPath string, encFileHash, fileHash, mediaKey []byte, fileLength int, mediaType MediaType, mmsType string) (data []byte, err error)
```

DownloadMediaWithPath downloads an attachment by manually specifying the path and encryption details.

<a name="Client.DownloadMediaWithPathToFile"></a>
### func \(\*Client\) DownloadMediaWithPathToFile

```go
func (cli *Client) DownloadMediaWithPathToFile(ctx context.Context, directPath string, encFileHash, fileHash, mediaKey []byte, fileLength int, mediaType MediaType, mmsType string, file File) error
```



<a name="Client.DownloadThumbnail"></a>
### func \(\*Client\) DownloadThumbnail

```go
func (cli *Client) DownloadThumbnail(ctx context.Context, msg DownloadableThumbnail) ([]byte, error)
```

DownloadThumbnail downloads a thumbnail from a message.

This is primarily intended for downloading link preview thumbnails, which are in ExtendedTextMessage:

```
var msg *waE2E.Message
...
thumbnailImageBytes, err := cli.DownloadThumbnail(msg.GetExtendedTextMessage())
```

<a name="Client.DownloadToFile"></a>
### func \(\*Client\) DownloadToFile

```go
func (cli *Client) DownloadToFile(ctx context.Context, msg DownloadableMessage, file File) error
```

DownloadToFile downloads the attachment from the given protobuf message.

This is otherwise identical to \[Download\], but writes the attachment to a file instead of returning it as a byte slice.

<a name="Client.EncryptComment"></a>
### func \(\*Client\) EncryptComment

```go
func (cli *Client) EncryptComment(ctx context.Context, rootMsgInfo *types.MessageInfo, comment *waE2E.Message) (*waE2E.Message, error)
```



<a name="Client.EncryptPollVote"></a>
### func \(\*Client\) EncryptPollVote

```go
func (cli *Client) EncryptPollVote(ctx context.Context, pollInfo *types.MessageInfo, vote *waE2E.PollVoteMessage) (*waE2E.PollUpdateMessage, error)
```

EncryptPollVote encrypts a poll vote message. This is a slightly lower\-level function, using BuildPollVote is recommended.

<a name="Client.EncryptReaction"></a>
### func \(\*Client\) EncryptReaction

```go
func (cli *Client) EncryptReaction(ctx context.Context, rootMsgInfo *types.MessageInfo, reaction *waE2E.ReactionMessage) (*waE2E.EncReactionMessage, error)
```



<a name="Client.FetchAppState"></a>
### func \(\*Client\) FetchAppState

```go
func (cli *Client) FetchAppState(ctx context.Context, name appstate.WAPatchName, fullSync, onlyIfNotSynced bool) error
```

FetchAppState fetches updates to the given type of app state. If fullSync is true, the current cached state will be removed and all app state patches will be re\-fetched from the server.

<a name="Client.FollowNewsletter"></a>
### func \(\*Client\) FollowNewsletter

```go
func (cli *Client) FollowNewsletter(ctx context.Context, jid types.JID) error
```

FollowNewsletter makes the user follow \(join\) a WhatsApp channel.

<a name="Client.GenerateMessageID"></a>
### func \(\*Client\) GenerateMessageID

```go
func (cli *Client) GenerateMessageID() types.MessageID
```

GenerateMessageID generates a random string that can be used as a message ID on WhatsApp.

```
msgID := cli.GenerateMessageID()
cli.SendMessage(context.Background(), targetJID, &waE2E.Message{...}, whatsmeow.SendRequestExtra{ID: msgID})
```

<a name="Client.GetBlocklist"></a>
### func \(\*Client\) GetBlocklist

```go
func (cli *Client) GetBlocklist(ctx context.Context) (*types.Blocklist, error)
```

GetBlocklist gets the list of users that this user has blocked.

<a name="Client.GetBotListV2"></a>
### func \(\*Client\) GetBotListV2

```go
func (cli *Client) GetBotListV2(ctx context.Context) ([]types.BotListInfo, error)
```



<a name="Client.GetBotProfiles"></a>
### func \(\*Client\) GetBotProfiles

```go
func (cli *Client) GetBotProfiles(ctx context.Context, botInfo []types.BotListInfo) ([]types.BotProfileInfo, error)
```



<a name="Client.GetBusinessProfile"></a>
### func \(\*Client\) GetBusinessProfile

```go
func (cli *Client) GetBusinessProfile(ctx context.Context, jid types.JID) (*types.BusinessProfile, error)
```

GetBusinessProfile gets the profile info of a WhatsApp business account

<a name="Client.GetContactQRLink"></a>
### func \(\*Client\) GetContactQRLink

```go
func (cli *Client) GetContactQRLink(ctx context.Context, revoke bool) (string, error)
```

GetContactQRLink gets your own contact share QR link that can be resolved using ResolveContactQRLink \(or scanned with the official apps when encoded as a QR code\).

If the revoke parameter is set to true, it will ask the server to revoke the previous link and generate a new one.

<a name="Client.GetGroupInfo"></a>
### func \(\*Client\) GetGroupInfo

```go
func (cli *Client) GetGroupInfo(ctx context.Context, jid types.JID) (*types.GroupInfo, error)
```

GetGroupInfo requests basic info about a group chat from the WhatsApp servers.

<a name="Client.GetGroupInfoFromInvite"></a>
### func \(\*Client\) GetGroupInfoFromInvite

```go
func (cli *Client) GetGroupInfoFromInvite(ctx context.Context, jid, inviter types.JID, code string, expiration int64) (*types.GroupInfo, error)
```

GetGroupInfoFromInvite gets the group info from an invite message.

Note that this is specifically for invite messages, not invite links. Use GetGroupInfoFromLink for resolving chat.whatsapp.com links.

<a name="Client.GetGroupInfoFromLink"></a>
### func \(\*Client\) GetGroupInfoFromLink

```go
func (cli *Client) GetGroupInfoFromLink(ctx context.Context, code string) (*types.GroupInfo, error)
```

GetGroupInfoFromLink resolves the given invite link and asks the WhatsApp servers for info about the group. This will not cause the user to join the group.

<a name="Client.GetGroupInviteLink"></a>
### func \(\*Client\) GetGroupInviteLink

```go
func (cli *Client) GetGroupInviteLink(ctx context.Context, jid types.JID, reset bool) (string, error)
```

GetGroupInviteLink requests the invite link to the group from the WhatsApp servers.

If reset is true, then the old invite link will be revoked and a new one generated.

<a name="Client.GetGroupRequestParticipants"></a>
### func \(\*Client\) GetGroupRequestParticipants

```go
func (cli *Client) GetGroupRequestParticipants(ctx context.Context, jid types.JID) ([]types.GroupParticipantRequest, error)
```

GetGroupRequestParticipants gets the list of participants that have requested to join the group.

<a name="Client.GetJoinedGroups"></a>
### func \(\*Client\) GetJoinedGroups

```go
func (cli *Client) GetJoinedGroups(ctx context.Context) ([]*types.GroupInfo, error)
```

GetJoinedGroups returns the list of groups the user is participating in.

<a name="Client.GetLinkedGroupsParticipants"></a>
### func \(\*Client\) GetLinkedGroupsParticipants

```go
func (cli *Client) GetLinkedGroupsParticipants(ctx context.Context, community types.JID) ([]types.JID, error)
```

GetLinkedGroupsParticipants gets all the participants in the groups of the given community.

<a name="Client.GetNewsletterInfo"></a>
### func \(\*Client\) GetNewsletterInfo

```go
func (cli *Client) GetNewsletterInfo(ctx context.Context, jid types.JID) (*types.NewsletterMetadata, error)
```

GetNewsletterInfo gets the info of a newsletter that you're joined to.

<a name="Client.GetNewsletterInfoWithInvite"></a>
### func \(\*Client\) GetNewsletterInfoWithInvite

```go
func (cli *Client) GetNewsletterInfoWithInvite(ctx context.Context, key string) (*types.NewsletterMetadata, error)
```

GetNewsletterInfoWithInvite gets the info of a newsletter with an invite link.

You can either pass the full link \(https://whatsapp.com/channel/...\) or just the \`...\` part.

Note that the ViewerMeta field of the returned NewsletterMetadata will be nil.

<a name="Client.GetNewsletterMessageUpdates"></a>
### func \(\*Client\) GetNewsletterMessageUpdates

```go
func (cli *Client) GetNewsletterMessageUpdates(ctx context.Context, jid types.JID, params *GetNewsletterUpdatesParams) ([]*types.NewsletterMessage, error)
```

GetNewsletterMessageUpdates gets updates in a WhatsApp channel.

These are the same kind of updates that NewsletterSubscribeLiveUpdates triggers \(reaction and view counts\).

<a name="Client.GetNewsletterMessages"></a>
### func \(\*Client\) GetNewsletterMessages

```go
func (cli *Client) GetNewsletterMessages(ctx context.Context, jid types.JID, params *GetNewsletterMessagesParams) ([]*types.NewsletterMessage, error)
```

GetNewsletterMessages gets messages in a WhatsApp channel.

<a name="Client.GetPrivacySettings"></a>
### func \(\*Client\) GetPrivacySettings

```go
func (cli *Client) GetPrivacySettings(ctx context.Context) (settings types.PrivacySettings)
```

GetPrivacySettings will get the user's privacy settings. If an error occurs while fetching them, the error will be logged, but the method will just return an empty struct.

<a name="Client.GetProfilePictureInfo"></a>
### func \(\*Client\) GetProfilePictureInfo

```go
func (cli *Client) GetProfilePictureInfo(ctx context.Context, jid types.JID, params *GetProfilePictureParams) (*types.ProfilePictureInfo, error)
```

GetProfilePictureInfo gets the URL where you can download a WhatsApp user's profile picture or group's photo.

Optionally, you can pass the last known profile picture ID. If the profile picture hasn't changed, this will return nil with no error.

To get a community photo, you should pass \`IsCommunity: true\`, as otherwise you may get a 401 error.

<a name="Client.GetQRChannel"></a>
### func \(\*Client\) GetQRChannel

```go
func (cli *Client) GetQRChannel(ctx context.Context) (<-chan QRChannelItem, error)
```

GetQRChannel returns a channel that automatically outputs a new QR code when the previous one expires.

This must be called \*before\* Connect\(\). It will then listen to all the relevant events from the client.

The last value to be emitted will be a special event like "success", "timeout" or another error code depending on the result of the pairing. The channel will be closed immediately after one of those.

<a name="Client.GetServerPushNotificationConfig"></a>
### func \(\*Client\) GetServerPushNotificationConfig

```go
func (cli *Client) GetServerPushNotificationConfig(ctx context.Context) (*waBinary.Node, error)
```



<a name="Client.GetStatusPrivacy"></a>
### func \(\*Client\) GetStatusPrivacy

```go
func (cli *Client) GetStatusPrivacy(ctx context.Context) ([]types.StatusPrivacy, error)
```

GetStatusPrivacy gets the user's status privacy settings \(who to send status broadcasts to\).

There can be multiple different stored settings, the first one is always the default.

<a name="Client.GetSubGroups"></a>
### func \(\*Client\) GetSubGroups

```go
func (cli *Client) GetSubGroups(ctx context.Context, community types.JID) ([]*types.GroupLinkTarget, error)
```

GetSubGroups gets the subgroups of the given community.

<a name="Client.GetSubscribedNewsletters"></a>
### func \(\*Client\) GetSubscribedNewsletters

```go
func (cli *Client) GetSubscribedNewsletters(ctx context.Context) ([]*types.NewsletterMetadata, error)
```

GetSubscribedNewsletters gets the info of all newsletters that you're joined to.

<a name="Client.GetUserDevices"></a>
### func \(\*Client\) GetUserDevices

```go
func (cli *Client) GetUserDevices(ctx context.Context, jids []types.JID) ([]types.JID, error)
```

GetUserDevices gets the list of devices that the given user has. The input should be a list of regular JIDs, and the output will be a list of AD JIDs. The local device will not be included in the output even if the user's JID is included in the input. All other devices will be included.

<a name="Client.GetUserDevicesContext"></a>
### func \(\*Client\) GetUserDevicesContext

```go
func (cli *Client) GetUserDevicesContext(ctx context.Context, jids []types.JID) ([]types.JID, error)
```



<a name="Client.GetUserInfo"></a>
### func \(\*Client\) GetUserInfo

```go
func (cli *Client) GetUserInfo(ctx context.Context, jids []types.JID) (map[types.JID]types.UserInfo, error)
```

GetUserInfo gets basic user info \(avatar, status, verified business name, device list\).

<a name="Client.IsConnected"></a>
### func \(\*Client\) IsConnected

```go
func (cli *Client) IsConnected() bool
```

IsConnected checks if the client is connected to the WhatsApp web websocket. Note that this doesn't check if the client is authenticated. See the IsLoggedIn field for that.

<a name="Client.IsLoggedIn"></a>
### func \(\*Client\) IsLoggedIn

```go
func (cli *Client) IsLoggedIn() bool
```

IsLoggedIn returns true after the client is successfully connected and authenticated on WhatsApp.

<a name="Client.IsOnWhatsApp"></a>
### func \(\*Client\) IsOnWhatsApp

```go
func (cli *Client) IsOnWhatsApp(ctx context.Context, phones []string) ([]types.IsOnWhatsAppResponse, error)
```

IsOnWhatsApp checks if the given phone numbers are registered on WhatsApp. The phone numbers should be in international format, including the \`\+\` prefix.

<a name="Client.JoinGroupWithInvite"></a>
### func \(\*Client\) JoinGroupWithInvite

```go
func (cli *Client) JoinGroupWithInvite(ctx context.Context, jid, inviter types.JID, code string, expiration int64) error
```

JoinGroupWithInvite joins a group using an invite message.

Note that this is specifically for invite messages, not invite links. Use JoinGroupWithLink for joining with chat.whatsapp.com links.

<a name="Client.JoinGroupWithLink"></a>
### func \(\*Client\) JoinGroupWithLink

```go
func (cli *Client) JoinGroupWithLink(ctx context.Context, code string) (types.JID, error)
```

JoinGroupWithLink joins the group using the given invite link.

<a name="Client.LeaveGroup"></a>
### func \(\*Client\) LeaveGroup

```go
func (cli *Client) LeaveGroup(ctx context.Context, jid types.JID) error
```

LeaveGroup leaves the specified group on WhatsApp.

<a name="Client.LinkGroup"></a>
### func \(\*Client\) LinkGroup

```go
func (cli *Client) LinkGroup(ctx context.Context, parent, child types.JID) error
```

LinkGroup adds an existing group as a child group in a community.

To create a new group within a community, set LinkedParentJID in the CreateGroup request.

<a name="Client.Logout"></a>
### func \(\*Client\) Logout

```go
func (cli *Client) Logout(ctx context.Context) error
```

Logout sends a request to unlink the device, then disconnects from the websocket and deletes the local device store.

If the logout request fails, the disconnection and local data deletion will not happen either. If an error is returned, but you want to force disconnect/clear data, call Client.Disconnect\(\) and Client.Store.Delete\(\) manually.

Note that this will not emit any events. The LoggedOut event is only used for external logouts \(triggered by the user from the main device or by WhatsApp servers\).

<a name="Client.MarkNotDirty"></a>
### func \(\*Client\) MarkNotDirty

```go
func (cli *Client) MarkNotDirty(ctx context.Context, cleanType string, ts time.Time) error
```



<a name="Client.MarkRead"></a>
### func \(\*Client\) MarkRead

```go
func (cli *Client) MarkRead(ctx context.Context, ids []types.MessageID, timestamp time.Time, chat, sender types.JID, receiptTypeExtra ...types.ReceiptType) error
```

MarkRead sends a read receipt for the given message IDs including the given timestamp as the read at time.

The first JID parameter \(chat\) must always be set to the chat ID \(user ID in DMs and group ID in group chats\). The second JID parameter \(sender\) must be set in group chats and must be the user ID who sent the message.

You can mark multiple messages as read at the same time, but only if the messages were sent by the same user. To mark messages by different users as read, you must call MarkRead multiple times \(once for each user\).

To mark a voice message as played, specify types.ReceiptTypePlayed as the last parameter. Providing more than one receipt type will panic: the parameter is only a vararg for backwards compatibility.

<a name="Client.NewsletterMarkViewed"></a>
### func \(\*Client\) NewsletterMarkViewed

```go
func (cli *Client) NewsletterMarkViewed(ctx context.Context, jid types.JID, serverIDs []types.MessageServerID) error
```

NewsletterMarkViewed marks a channel message as viewed, incrementing the view counter.

This is not the same as marking the channel as read on your other devices, use the usual MarkRead function for that.

<a name="Client.NewsletterSendReaction"></a>
### func \(\*Client\) NewsletterSendReaction

```go
func (cli *Client) NewsletterSendReaction(ctx context.Context, jid types.JID, serverID types.MessageServerID, reaction string, messageID types.MessageID) error
```

NewsletterSendReaction sends a reaction to a channel message. To remove a reaction sent earlier, set reaction to an empty string.

The last parameter is the message ID of the reaction itself. It can be left empty to let whatsmeow generate a random one.

<a name="Client.NewsletterSubscribeLiveUpdates"></a>
### func \(\*Client\) NewsletterSubscribeLiveUpdates

```go
func (cli *Client) NewsletterSubscribeLiveUpdates(ctx context.Context, jid types.JID) (time.Duration, error)
```

NewsletterSubscribeLiveUpdates subscribes to receive live updates from a WhatsApp channel temporarily \(for the duration returned\).

<a name="Client.NewsletterToggleMute"></a>
### func \(\*Client\) NewsletterToggleMute

```go
func (cli *Client) NewsletterToggleMute(ctx context.Context, jid types.JID, mute bool) error
```

NewsletterToggleMute changes the mute status of a newsletter.

<a name="Client.PairPhone"></a>
### func \(\*Client\) PairPhone

```go
func (cli *Client) PairPhone(ctx context.Context, phone string, showPushNotification bool, clientType PairClientType, clientDisplayName string) (string, error)
```

PairPhone generates a pairing code that can be used to link to a phone without scanning a QR code.

You must connect the client normally before calling this \(which means you'll also receive a QR code event, but that can be ignored when doing code pairing\). You should also wait for \`\*events.QR\` before calling this to ensure the connection is fully established. If using [Client.GetQRChannel](<#Client.GetQRChannel>), wait for the first item in the channel. Alternatively, sleeping for a second after calling Connect will probably work too.

The exact expiry of pairing codes is unknown, but QR codes are always generated and the login websocket is closed after the QR codes run out, which means there's a 160\-second time limit. It is recommended to generate the pairing code immediately after connecting to the websocket to have the maximum time.

The clientType parameter must be one of the PairClient\* constants, but which one doesn't matter. The client display name must be formatted as \`Browser \(OS\)\`, and only common browsers/OSes are allowed \(the server will validate it and return 400 if it's wrong\).

See https://faq.whatsapp.com/1324084875126592 for more info

<a name="Client.ParseWebMessage"></a>
### func \(\*Client\) ParseWebMessage

```go
func (cli *Client) ParseWebMessage(chatJID types.JID, webMsg *waWeb.WebMessageInfo) (*events.Message, error)
```

ParseWebMessage parses a WebMessageInfo object into \*events.Message to match what real\-time messages have.

The chat JID can be found in the Conversation data:

```
chatJID, err := types.ParseJID(conv.GetId())
for _, historyMsg := range conv.GetMessages() {
	evt, err := cli.ParseWebMessage(chatJID, historyMsg.GetMessage())
	yourNormalEventHandler(evt)
}
```

<a name="Client.RegisterForPushNotifications"></a>
### func \(\*Client\) RegisterForPushNotifications

```go
func (cli *Client) RegisterForPushNotifications(ctx context.Context, pc PushConfig) error
```

RegisterForPushNotifications registers a token to receive push notifications for new WhatsApp messages.

This is generally not necessary for anything. Don't use this if you don't know what you're doing.

<a name="Client.RejectCall"></a>
### func \(\*Client\) RejectCall

```go
func (cli *Client) RejectCall(ctx context.Context, callFrom types.JID, callID string) error
```

RejectCall reject an incoming call.

<a name="Client.RemoveEventHandler"></a>
### func \(\*Client\) RemoveEventHandler

```go
func (cli *Client) RemoveEventHandler(id uint32) bool
```

RemoveEventHandler removes a previously registered event handler function. If the function with the given ID is found, this returns true.

N.B. Do not run this directly from an event handler. That would cause a deadlock because the event dispatcher holds a read lock on the event handler list, and this method wants a write lock on the same list. Instead run it in a goroutine:

```
func (mycli *MyClient) myEventHandler(evt interface{}) {
	if noLongerWantEvents {
		go mycli.WAClient.RemoveEventHandler(mycli.eventHandlerID)
	}
}
```

<a name="Client.RemoveEventHandlers"></a>
### func \(\*Client\) RemoveEventHandlers

```go
func (cli *Client) RemoveEventHandlers()
```

RemoveEventHandlers removes all event handlers that have been registered with AddEventHandler

<a name="Client.ResetConnection"></a>
### func \(\*Client\) ResetConnection

```go
func (cli *Client) ResetConnection()
```

ResetConnection disconnects from the WhatsApp web websocket and forces an automatic reconnection. This will not do anything if the socket is already disconnected or if EnableAutoReconnect is false.

<a name="Client.ResolveBusinessMessageLink"></a>
### func \(\*Client\) ResolveBusinessMessageLink

```go
func (cli *Client) ResolveBusinessMessageLink(ctx context.Context, code string) (*types.BusinessMessageLinkTarget, error)
```

ResolveBusinessMessageLink resolves a business message short link and returns the target JID, business name and text to prefill in the input field \(if any\).

The links look like https://wa.me/message/\<code\> or https://api.whatsapp.com/message/\<code\>. You can either provide the full link, or just the \<code\> part.

<a name="Client.ResolveContactQRLink"></a>
### func \(\*Client\) ResolveContactQRLink

```go
func (cli *Client) ResolveContactQRLink(ctx context.Context, code string) (*types.ContactQRLinkTarget, error)
```

ResolveContactQRLink resolves a link from a contact share QR code and returns the target JID and push name.

The links look like https://wa.me/qr/\<code\> or https://api.whatsapp.com/qr/\<code\>. You can either provide the full link, or just the \<code\> part.

<a name="Client.RevokeMessage"></a>
### func \(\*Client\) RevokeMessage

```go
func (cli *Client) RevokeMessage(ctx context.Context, chat types.JID, id types.MessageID) (SendResponse, error)
```

RevokeMessage deletes the given message from everyone in the chat.

This method will wait for the server to acknowledge the revocation message before returning. The return value is the timestamp of the message from the server.

Deprecated: This method is deprecated in favor of BuildRevoke

<a name="Client.SendAppState"></a>
### func \(\*Client\) SendAppState

```go
func (cli *Client) SendAppState(ctx context.Context, patch appstate.PatchInfo) error
```

SendAppState sends the given app state patch, then triggers a background resync of that app state type to update local caches and send events for the updates.

You can use the Build methods in the appstate package to build the parameter for this method, e.g.

```
cli.SendAppState(ctx, appstate.BuildMute(targetJID, true, 24 * time.Hour))
```

<a name="Client.SendChatPresence"></a>
### func \(\*Client\) SendChatPresence

```go
func (cli *Client) SendChatPresence(ctx context.Context, jid types.JID, state types.ChatPresence, media types.ChatPresenceMedia) error
```

SendChatPresence updates the user's typing status in a specific chat.

The media parameter can be set to indicate the user is recording media \(like a voice message\) rather than typing a text message.

<a name="Client.SendFBMessage"></a>
### func \(\*Client\) SendFBMessage

```go
func (cli *Client) SendFBMessage(ctx context.Context, to types.JID, message armadillo.RealMessageApplicationSub, metadata *waMsgApplication.MessageApplication_Metadata, extra ...SendRequestExtra) (resp SendResponse, err error)
```

SendFBMessage sends the given v3 message to the given JID.

<a name="Client.SendMediaRetryReceipt"></a>
### func \(\*Client\) SendMediaRetryReceipt

```go
func (cli *Client) SendMediaRetryReceipt(ctx context.Context, message *types.MessageInfo, mediaKey []byte) error
```

SendMediaRetryReceipt sends a request to the phone to re\-upload the media in a message.

This is mostly relevant when handling history syncs and getting a 404 or 410 error downloading media. Rough example on how to use it \(will not work out of the box, you must adjust it depending on what you need exactly\):

```
var mediaRetryCache map[types.MessageID]*waE2E.ImageMessage

evt, err := cli.ParseWebMessage(chatJID, historyMsg.GetMessage())
imageMsg := evt.Message.GetImageMessage() // replace this with the part of the message you want to download
data, err := cli.Download(imageMsg)
if errors.Is(err, whatsmeow.ErrMediaDownloadFailedWith404) || errors.Is(err, whatsmeow.ErrMediaDownloadFailedWith410) {
  err = cli.SendMediaRetryReceipt(&evt.Info, imageMsg.GetMediaKey())
  // You need to store the event data somewhere as it's necessary for handling the retry response.
  mediaRetryCache[evt.Info.ID] = imageMsg
}
```

The response will come as an \*events.MediaRetry. The response will then have to be decrypted using DecryptMediaRetryNotification and the same media key passed here. If the media retry was successful, the decrypted notification should contain an updated DirectPath, which can be used to download the file.

```
func eventHandler(rawEvt interface{}) {
  switch evt := rawEvt.(type) {
  case *events.MediaRetry:
    imageMsg := mediaRetryCache[evt.MessageID]
    retryData, err := whatsmeow.DecryptMediaRetryNotification(evt, imageMsg.GetMediaKey())
    if err != nil || retryData.GetResult != waMmsRetry.MediaRetryNotification_SUCCESS {
      return
    }
    // Use the new path to download the attachment
    imageMsg.DirectPath = retryData.DirectPath
    data, err := cli.Download(imageMsg)
    // Alternatively, you can use cli.DownloadMediaWithPath and provide the individual fields manually.
  }
}
```

<a name="Client.SendMessage"></a>
### func \(\*Client\) SendMessage

```go
func (cli *Client) SendMessage(ctx context.Context, to types.JID, message *waE2E.Message, extra ...SendRequestExtra) (resp SendResponse, err error)
```

SendMessage sends the given message.

This method will wait for the server to acknowledge the message before returning. The return value is the timestamp of the message from the server.

Optional parameters like the message ID can be specified with the SendRequestExtra struct. Only one extra parameter is allowed, put all necessary parameters in the same struct.

The message itself can contain anything you want \(within the protobuf schema\). e.g. for a simple text message, use the Conversation field:

```
cli.SendMessage(context.Background(), targetJID, &waE2E.Message{
	Conversation: proto.String("Hello, World!"),
})
```

Things like replies, mentioning users and the "forwarded" flag are stored in ContextInfo, which can be put in ExtendedTextMessage and any of the media message types.

For uploading and sending media/attachments, see the Upload method.

For other message types, you'll have to figure it out yourself. Looking at the protobuf schema in binary/proto/def.proto may be useful to find out all the allowed fields. Printing the RawMessage field in incoming message events to figure out what it contains is also a good way to learn how to send the same kind of message.

<a name="Client.SendPresence"></a>
### func \(\*Client\) SendPresence

```go
func (cli *Client) SendPresence(ctx context.Context, state types.Presence) error
```

SendPresence updates the user's presence status on WhatsApp.

You should call this at least once after connecting so that the server has your pushname. Otherwise, other users will see "\-" as the name.

<a name="Client.SetDefaultDisappearingTimer"></a>
### func \(\*Client\) SetDefaultDisappearingTimer

```go
func (cli *Client) SetDefaultDisappearingTimer(ctx context.Context, timer time.Duration) (err error)
```

SetDefaultDisappearingTimer will set the default disappearing message timer.

<a name="Client.SetDisappearingTimer"></a>
### func \(\*Client\) SetDisappearingTimer

```go
func (cli *Client) SetDisappearingTimer(ctx context.Context, chat types.JID, timer time.Duration, settingTS time.Time) (err error)
```

SetDisappearingTimer sets the disappearing timer in a chat. Both private chats and groups are supported, but they're set with different methods.

Note that while this function allows passing non\-standard durations, official WhatsApp apps will ignore those, and in groups the server will just reject the change. You can use the DisappearingTimer\<Duration\> constants for convenience.

In groups, the server will echo the change as a notification, so it'll show up as a \*events.GroupInfo update.

<a name="Client.SetForceActiveDeliveryReceipts"></a>
### func \(\*Client\) SetForceActiveDeliveryReceipts

```go
func (cli *Client) SetForceActiveDeliveryReceipts(active bool)
```

SetForceActiveDeliveryReceipts will force the client to send normal delivery receipts \(which will show up as the two gray ticks on WhatsApp\), even if the client isn't marked as online.

By default, clients that haven't been marked as online will send delivery receipts with type="inactive", which is transmitted to the sender, but not rendered in the official WhatsApp apps. This is consistent with how WhatsApp web works when it's not in the foreground.

To mark the client as online, use

```
cli.SendPresence(types.PresenceAvailable)
```

Note that if you turn this off \(i.e. call SetForceActiveDeliveryReceipts\(false\)\), receipts will act like the client is offline until SendPresence is called again.

<a name="Client.SetGroupAnnounce"></a>
### func \(\*Client\) SetGroupAnnounce

```go
func (cli *Client) SetGroupAnnounce(ctx context.Context, jid types.JID, announce bool) error
```

SetGroupAnnounce changes whether the group is in announce mode \(i.e. whether only admins can send messages\).

<a name="Client.SetGroupDescription"></a>
### func \(\*Client\) SetGroupDescription

```go
func (cli *Client) SetGroupDescription(ctx context.Context, jid types.JID, description string) error
```

SetGroupDescription updates the group description.

<a name="Client.SetGroupJoinApprovalMode"></a>
### func \(\*Client\) SetGroupJoinApprovalMode

```go
func (cli *Client) SetGroupJoinApprovalMode(ctx context.Context, jid types.JID, mode bool) error
```

SetGroupJoinApprovalMode sets the group join approval mode to 'on' or 'off'.

<a name="Client.SetGroupLocked"></a>
### func \(\*Client\) SetGroupLocked

```go
func (cli *Client) SetGroupLocked(ctx context.Context, jid types.JID, locked bool) error
```

SetGroupLocked changes whether the group is locked \(i.e. whether only admins can modify group info\).

<a name="Client.SetGroupMemberAddMode"></a>
### func \(\*Client\) SetGroupMemberAddMode

```go
func (cli *Client) SetGroupMemberAddMode(ctx context.Context, jid types.JID, mode types.GroupMemberAddMode) error
```

SetGroupMemberAddMode sets the group member add mode to 'admin\_add' or 'all\_member\_add'.

<a name="Client.SetGroupName"></a>
### func \(\*Client\) SetGroupName

```go
func (cli *Client) SetGroupName(ctx context.Context, jid types.JID, name string) error
```

SetGroupName updates the name \(subject\) of the given group on WhatsApp.

<a name="Client.SetGroupPhoto"></a>
### func \(\*Client\) SetGroupPhoto

```go
func (cli *Client) SetGroupPhoto(ctx context.Context, jid types.JID, avatar []byte) (string, error)
```

SetGroupPhoto updates the group picture/icon of the given group on WhatsApp. The avatar should be a JPEG photo, other formats may be rejected with ErrInvalidImageFormat. The bytes can be nil to remove the photo. Returns the new picture ID.

<a name="Client.SetGroupTopic"></a>
### func \(\*Client\) SetGroupTopic

```go
func (cli *Client) SetGroupTopic(ctx context.Context, jid types.JID, previousID, newID, topic string) error
```

SetGroupTopic updates the topic \(description\) of the given group on WhatsApp.

The previousID and newID fields are optional. If the previous ID is not specified, this will automatically fetch the current group info to find the previous topic ID. If the new ID is not specified, one will be generated with Client.GenerateMessageID\(\).

<a name="Client.SetMediaHTTPClient"></a>
### func \(\*Client\) SetMediaHTTPClient

```go
func (cli *Client) SetMediaHTTPClient(h *http.Client)
```

SetMediaHTTPClient sets the HTTP client used to download media. This will overwrite any set proxy calls.

<a name="Client.SetPassive"></a>
### func \(\*Client\) SetPassive

```go
func (cli *Client) SetPassive(ctx context.Context, passive bool) error
```

SetPassive tells the WhatsApp server whether this device is passive or not.

This seems to mostly affect whether the device receives certain events. By default, whatsmeow will automatically do SetPassive\(false\) after connecting.

<a name="Client.SetPreLoginHTTPClient"></a>
### func \(\*Client\) SetPreLoginHTTPClient

```go
func (cli *Client) SetPreLoginHTTPClient(h *http.Client)
```

SetPreLoginHTTPClient sets the HTTP client used to establish the websocket connection before login. This will overwrite any set proxy calls.

<a name="Client.SetPrivacySetting"></a>
### func \(\*Client\) SetPrivacySetting

```go
func (cli *Client) SetPrivacySetting(ctx context.Context, name types.PrivacySettingType, value types.PrivacySetting) (settings types.PrivacySettings, err error)
```

SetPrivacySetting will set the given privacy setting to the given value. The privacy settings will be fetched from the server after the change and the new settings will be returned. If an error occurs while fetching the new settings, will return an empty struct.

<a name="Client.SetProxy"></a>
### func \(\*Client\) SetProxy

```go
func (cli *Client) SetProxy(proxy Proxy, opts ...SetProxyOptions)
```

SetProxy sets a HTTP proxy to use for WhatsApp web websocket connections and media uploads/downloads.

Must be called before Connect\(\) to take effect in the websocket connection. If you want to change the proxy after connecting, you must call Disconnect\(\) and then Connect\(\) again manually.

By default, the client will find the proxy from the https\_proxy environment variable like Go's net/http does.

To disable reading proxy info from environment variables, explicitly set the proxy to nil:

```
cli.SetProxy(nil)
```

To use a different proxy for the websocket and media, pass a function that checks the request path or headers:

```
cli.SetProxy(func(r *http.Request) (*url.URL, error) {
	if r.URL.Host == "web.whatsapp.com" && r.URL.Path == "/ws/chat" {
		return websocketProxyURL, nil
	} else {
		return mediaProxyURL, nil
	}
})
```

<a name="Client.SetProxyAddress"></a>
### func \(\*Client\) SetProxyAddress

```go
func (cli *Client) SetProxyAddress(addr string, opts ...SetProxyOptions) error
```

SetProxyAddress is a helper method that parses a URL string and calls SetProxy or SetSOCKSProxy based on the URL scheme.

Returns an error if url.Parse fails to parse the given address.

<a name="Client.SetSOCKSProxy"></a>
### func \(\*Client\) SetSOCKSProxy

```go
func (cli *Client) SetSOCKSProxy(px proxy.Dialer, opts ...SetProxyOptions)
```

SetSOCKSProxy sets a SOCKS5 proxy to use for WhatsApp web websocket connections and media uploads/downloads.

Same details as SetProxy apply, but using a different proxy for the websocket and media is not currently supported.

<a name="Client.SetStatusMessage"></a>
### func \(\*Client\) SetStatusMessage

```go
func (cli *Client) SetStatusMessage(ctx context.Context, msg string) error
```

SetStatusMessage updates the current user's status text, which is shown in the "About" section in the user profile.

This is different from the ephemeral status broadcast messages. Use SendMessage to types.StatusBroadcastJID to send such messages.

<a name="Client.SetWebsocketHTTPClient"></a>
### func \(\*Client\) SetWebsocketHTTPClient

```go
func (cli *Client) SetWebsocketHTTPClient(h *http.Client)
```

SetWebsocketHTTPClient sets the HTTP client used to establish the websocket connection for logged\-in sessions. This will overwrite any set proxy calls.

<a name="Client.StoreLIDPNMapping"></a>
### func \(\*Client\) StoreLIDPNMapping

```go
func (cli *Client) StoreLIDPNMapping(ctx context.Context, first, second types.JID)
```



<a name="Client.SubscribePresence"></a>
### func \(\*Client\) SubscribePresence

```go
func (cli *Client) SubscribePresence(ctx context.Context, jid types.JID) error
```

SubscribePresence asks the WhatsApp servers to send presence updates of a specific user to this client.

After subscribing to this event, you should start receiving \*events.Presence for that user in normal event handlers.

Also, it seems that the WhatsApp servers require you to be online to receive presence status from other users, so you should mark yourself as online before trying to use this function:

```
cli.SendPresence(types.PresenceAvailable)
```

<a name="Client.TryFetchPrivacySettings"></a>
### func \(\*Client\) TryFetchPrivacySettings

```go
func (cli *Client) TryFetchPrivacySettings(ctx context.Context, ignoreCache bool) (*types.PrivacySettings, error)
```

TryFetchPrivacySettings will fetch the user's privacy settings, either from the in\-memory cache or from the server.

<a name="Client.UnfollowNewsletter"></a>
### func \(\*Client\) UnfollowNewsletter

```go
func (cli *Client) UnfollowNewsletter(ctx context.Context, jid types.JID) error
```

UnfollowNewsletter makes the user unfollow \(leave\) a WhatsApp channel.

<a name="Client.UnlinkGroup"></a>
### func \(\*Client\) UnlinkGroup

```go
func (cli *Client) UnlinkGroup(ctx context.Context, parent, child types.JID) error
```

UnlinkGroup removes a child group from a parent community.

<a name="Client.UpdateBlocklist"></a>
### func \(\*Client\) UpdateBlocklist

```go
func (cli *Client) UpdateBlocklist(ctx context.Context, jid types.JID, action events.BlocklistChangeAction) (*types.Blocklist, error)
```

UpdateBlocklist updates the user's block list and returns the updated list.

<a name="Client.UpdateGroupParticipants"></a>
### func \(\*Client\) UpdateGroupParticipants

```go
func (cli *Client) UpdateGroupParticipants(ctx context.Context, jid types.JID, participantChanges []types.JID, action ParticipantChange) ([]types.GroupParticipant, error)
```

UpdateGroupParticipants can be used to add, remove, promote and demote members in a WhatsApp group.

<a name="Client.UpdateGroupRequestParticipants"></a>
### func \(\*Client\) UpdateGroupRequestParticipants

```go
func (cli *Client) UpdateGroupRequestParticipants(ctx context.Context, jid types.JID, participantChanges []types.JID, action ParticipantRequestChange) ([]types.GroupParticipant, error)
```

UpdateGroupRequestParticipants can be used to approve or reject requests to join the group.

<a name="Client.Upload"></a>
### func \(\*Client\) Upload

```go
func (cli *Client) Upload(ctx context.Context, plaintext []byte, appInfo MediaType) (resp UploadResponse, err error)
```

Upload uploads the given attachment to WhatsApp servers.

You should copy the fields in the response to the corresponding fields in a protobuf message.

For example, to send an image:

```
resp, err := cli.Upload(context.Background(), yourImageBytes, whatsmeow.MediaImage)
// handle error

imageMsg := &waE2E.ImageMessage{
	Caption:  proto.String("Hello, world!"),
	Mimetype: proto.String("image/png"), // replace this with the actual mime type
	// you can also optionally add other fields like ContextInfo and JpegThumbnail here

	URL:           &resp.URL,
	DirectPath:    &resp.DirectPath,
	MediaKey:      resp.MediaKey,
	FileEncSHA256: resp.FileEncSHA256,
	FileSHA256:    resp.FileSHA256,
	FileLength:    &resp.FileLength,
}
_, err = cli.SendMessage(context.Background(), targetJID, &waE2E.Message{
	ImageMessage: imageMsg,
})
// handle error again
```

The same applies to the other message types like DocumentMessage, just replace the struct type and Message field name.

<a name="Client.UploadNewsletter"></a>
### func \(\*Client\) UploadNewsletter

```go
func (cli *Client) UploadNewsletter(ctx context.Context, data []byte, appInfo MediaType) (resp UploadResponse, err error)
```

UploadNewsletter uploads the given attachment to WhatsApp servers without encrypting it first.

Newsletter media works mostly the same way as normal media, with a few differences: \* Since it's unencrypted, there's no MediaKey or FileEncSHA256 fields. \* There's a "media handle" that needs to be passed in SendRequestExtra.

Example:

```
resp, err := cli.UploadNewsletter(context.Background(), yourImageBytes, whatsmeow.MediaImage)
// handle error

imageMsg := &waE2E.ImageMessage{
	// Caption, mime type and other such fields work like normal
	Caption:  proto.String("Hello, world!"),
	Mimetype: proto.String("image/png"),

	// URL and direct path are also there like normal media
	URL:        &resp.URL,
	DirectPath: &resp.DirectPath,
	FileSHA256: resp.FileSHA256,
	FileLength: &resp.FileLength,
	// Newsletter media isn't encrypted, so the media key and file enc sha fields are not applicable
}
_, err = cli.SendMessage(context.Background(), newsletterJID, &waE2E.Message{
	ImageMessage: imageMsg,
}, whatsmeow.SendRequestExtra{
	// Unlike normal media, newsletters also include a "media handle" in the send request.
	MediaHandle: resp.Handle,
})
// handle error again
```

<a name="Client.UploadNewsletterReader"></a>
### func \(\*Client\) UploadNewsletterReader

```go
func (cli *Client) UploadNewsletterReader(ctx context.Context, data io.ReadSeeker, appInfo MediaType) (resp UploadResponse, err error)
```

UploadNewsletterReader uploads the given attachment to WhatsApp servers without encrypting it first.

This is otherwise identical to \[UploadNewsletter\], but it reads the plaintext from an [io.Reader](<https://pkg.go.dev/io/#Reader>) instead of a byte slice. Unlike \[UploadReader\], this does not require a temporary file. However, the data needs to be hashed first, so an [io.ReadSeeker](<https://pkg.go.dev/io/#ReadSeeker>) is required to be able to read the data twice.

<a name="Client.UploadReader"></a>
### func \(\*Client\) UploadReader

```go
func (cli *Client) UploadReader(ctx context.Context, plaintext io.Reader, tempFile io.ReadWriteSeeker, appInfo MediaType) (resp UploadResponse, err error)
```

UploadReader uploads the given attachment to WhatsApp servers.

This is otherwise identical to \[Upload\], but it reads the plaintext from an [io.Reader](<https://pkg.go.dev/io/#Reader>) instead of a byte slice. A temporary file is required for the encryption process. If tempFile is nil, a temporary file will be created and deleted after the upload.

To use only one file, pass the same file as both plaintext and tempFile. This will cause the file to be overwritten with encrypted data.

<a name="Client.WaitForConnection"></a>
### func \(\*Client\) WaitForConnection

```go
func (cli *Client) WaitForConnection(timeout time.Duration) bool
```



<a name="CreateNewsletterParams"></a>
## type CreateNewsletterParams



```go
type CreateNewsletterParams struct {
    Name        string `json:"name"`
    Description string `json:"description,omitempty"`
    Picture     []byte `json:"picture,omitempty"`
}
```

<a name="DangerousInfoQuery"></a>
## type DangerousInfoQuery



```go
type DangerousInfoQuery = infoQuery
```

<a name="DangerousInfoQueryType"></a>
## type DangerousInfoQueryType



```go
type DangerousInfoQueryType = infoQueryType
```

<a name="DangerousInternalClient"></a>
## type DangerousInternalClient



```go
type DangerousInternalClient struct {
    // contains filtered or unexported fields
}
```

<a name="DangerousInternalClient.AddRecentMessage"></a>
### func \(\*DangerousInternalClient\) AddRecentMessage

```go
func (int *DangerousInternalClient) AddRecentMessage(to types.JID, id types.MessageID, wa *waE2E.Message, fb *waMsgApplication.MessageApplication)
```



<a name="DangerousInternalClient.ApplyAppStatePatches"></a>
### func \(\*DangerousInternalClient\) ApplyAppStatePatches

```go
func (int *DangerousInternalClient) ApplyAppStatePatches(ctx context.Context, name appstate.WAPatchName, state appstate.HashState, patches *appstate.PatchList, fullSync bool, eventsToDispatch *[]any) (appstate.HashState, error)
```



<a name="DangerousInternalClient.AutoReconnect"></a>
### func \(\*DangerousInternalClient\) AutoReconnect

```go
func (int *DangerousInternalClient) AutoReconnect(ctx context.Context)
```



<a name="DangerousInternalClient.BackgroundIfAsyncAck"></a>
### func \(\*DangerousInternalClient\) BackgroundIfAsyncAck

```go
func (int *DangerousInternalClient) BackgroundIfAsyncAck(fn func())
```



<a name="DangerousInternalClient.BufferedDecrypt"></a>
### func \(\*DangerousInternalClient\) BufferedDecrypt

```go
func (int *DangerousInternalClient) BufferedDecrypt(ctx context.Context, ciphertext []byte, serverTimestamp time.Time, decrypt func(context.Context) ([]byte, error)) (plaintext []byte, ciphertextHash [32]byte, err error)
```



<a name="DangerousInternalClient.CacheGroupInfo"></a>
### func \(\*DangerousInternalClient\) CacheGroupInfo

```go
func (int *DangerousInternalClient) CacheGroupInfo(groupInfo *types.GroupInfo, lock bool) ([]store.LIDMapping, []store.RedactedPhoneEntry)
```



<a name="DangerousInternalClient.CancelDelayedRequestFromPhone"></a>
### func \(\*DangerousInternalClient\) CancelDelayedRequestFromPhone

```go
func (int *DangerousInternalClient) CancelDelayedRequestFromPhone(msgID types.MessageID)
```



<a name="DangerousInternalClient.CancelResponse"></a>
### func \(\*DangerousInternalClient\) CancelResponse

```go
func (int *DangerousInternalClient) CancelResponse(reqID string, ch chan *waBinary.Node)
```



<a name="DangerousInternalClient.ClearDelayedMessageRequests"></a>
### func \(\*DangerousInternalClient\) ClearDelayedMessageRequests

```go
func (int *DangerousInternalClient) ClearDelayedMessageRequests()
```



<a name="DangerousInternalClient.ClearResponseWaiters"></a>
### func \(\*DangerousInternalClient\) ClearResponseWaiters

```go
func (int *DangerousInternalClient) ClearResponseWaiters(node *waBinary.Node)
```



<a name="DangerousInternalClient.ClearUntrustedIdentity"></a>
### func \(\*DangerousInternalClient\) ClearUntrustedIdentity

```go
func (int *DangerousInternalClient) ClearUntrustedIdentity(ctx context.Context, target types.JID) error
```



<a name="DangerousInternalClient.CloseSocketWaitChan"></a>
### func \(\*DangerousInternalClient\) CloseSocketWaitChan

```go
func (int *DangerousInternalClient) CloseSocketWaitChan()
```



<a name="DangerousInternalClient.Connect"></a>
### func \(\*DangerousInternalClient\) Connect

```go
func (int *DangerousInternalClient) Connect(ctx context.Context) error
```



<a name="DangerousInternalClient.DecryptBotMessage"></a>
### func \(\*DangerousInternalClient\) DecryptBotMessage

```go
func (int *DangerousInternalClient) DecryptBotMessage(ctx context.Context, messageSecret []byte, msMsg messageEncryptedSecret, messageID types.MessageID, targetSenderJID types.JID, info *types.MessageInfo) ([]byte, error)
```



<a name="DangerousInternalClient.DecryptDM"></a>
### func \(\*DangerousInternalClient\) DecryptDM

```go
func (int *DangerousInternalClient) DecryptDM(ctx context.Context, child *waBinary.Node, from types.JID, isPreKey bool, serverTS time.Time) ([]byte, *[32]byte, error)
```



<a name="DangerousInternalClient.DecryptGroupMsg"></a>
### func \(\*DangerousInternalClient\) DecryptGroupMsg

```go
func (int *DangerousInternalClient) DecryptGroupMsg(ctx context.Context, child *waBinary.Node, from types.JID, chat types.JID, serverTS time.Time) ([]byte, *[32]byte, error)
```



<a name="DangerousInternalClient.DecryptMessages"></a>
### func \(\*DangerousInternalClient\) DecryptMessages

```go
func (int *DangerousInternalClient) DecryptMessages(ctx context.Context, info *types.MessageInfo, node *waBinary.Node)
```



<a name="DangerousInternalClient.DecryptMsgSecret"></a>
### func \(\*DangerousInternalClient\) DecryptMsgSecret

```go
func (int *DangerousInternalClient) DecryptMsgSecret(ctx context.Context, msg *events.Message, useCase MsgSecretType, encrypted messageEncryptedSecret, origMsgKey *waCommon.MessageKey) ([]byte, error)
```



<a name="DangerousInternalClient.DelayedRequestMessageFromPhone"></a>
### func \(\*DangerousInternalClient\) DelayedRequestMessageFromPhone

```go
func (int *DangerousInternalClient) DelayedRequestMessageFromPhone(info *types.MessageInfo)
```



<a name="DangerousInternalClient.DispatchAppState"></a>
### func \(\*DangerousInternalClient\) DispatchAppState

```go
func (int *DangerousInternalClient) DispatchAppState(ctx context.Context, mutation appstate.Mutation, fullSync bool) (eventToDispatch any)
```



<a name="DangerousInternalClient.DispatchEvent"></a>
### func \(\*DangerousInternalClient\) DispatchEvent

```go
func (int *DangerousInternalClient) DispatchEvent(evt any) (handlerFailed bool)
```



<a name="DangerousInternalClient.DoHandshake"></a>
### func \(\*DangerousInternalClient\) DoHandshake

```go
func (int *DangerousInternalClient) DoHandshake(ctx context.Context, fs *socket.FrameSocket, ephemeralKP keys.KeyPair) error
```



<a name="DangerousInternalClient.DoMediaDownloadRequest"></a>
### func \(\*DangerousInternalClient\) DoMediaDownloadRequest

```go
func (int *DangerousInternalClient) DoMediaDownloadRequest(ctx context.Context, url string) (*http.Response, error)
```



<a name="DangerousInternalClient.DownloadAndDecrypt"></a>
### func \(\*DangerousInternalClient\) DownloadAndDecrypt

```go
func (int *DangerousInternalClient) DownloadAndDecrypt(ctx context.Context, url string, mediaKey []byte, appInfo MediaType, fileLength int, fileEncSHA256, fileSHA256 []byte) (data []byte, err error)
```



<a name="DangerousInternalClient.DownloadAndDecryptToFile"></a>
### func \(\*DangerousInternalClient\) DownloadAndDecryptToFile

```go
func (int *DangerousInternalClient) DownloadAndDecryptToFile(ctx context.Context, url string, mediaKey []byte, appInfo MediaType, fileLength int, fileEncSHA256, fileSHA256 []byte, file File) error
```



<a name="DangerousInternalClient.DownloadEncryptedMedia"></a>
### func \(\*DangerousInternalClient\) DownloadEncryptedMedia

```go
func (int *DangerousInternalClient) DownloadEncryptedMedia(ctx context.Context, url string, checksum []byte) (file, mac []byte, err error)
```



<a name="DangerousInternalClient.DownloadEncryptedMediaToFile"></a>
### func \(\*DangerousInternalClient\) DownloadEncryptedMediaToFile

```go
func (int *DangerousInternalClient) DownloadEncryptedMediaToFile(ctx context.Context, url string, checksum []byte, file File) ([]byte, error)
```



<a name="DangerousInternalClient.DownloadExternalAppStateBlob"></a>
### func \(\*DangerousInternalClient\) DownloadExternalAppStateBlob

```go
func (int *DangerousInternalClient) DownloadExternalAppStateBlob(ctx context.Context, ref *waServerSync.ExternalBlobReference) ([]byte, error)
```



<a name="DangerousInternalClient.DownloadMedia"></a>
### func \(\*DangerousInternalClient\) DownloadMedia

```go
func (int *DangerousInternalClient) DownloadMedia(ctx context.Context, url string) ([]byte, error)
```



<a name="DangerousInternalClient.DownloadMediaToFile"></a>
### func \(\*DangerousInternalClient\) DownloadMediaToFile

```go
func (int *DangerousInternalClient) DownloadMediaToFile(ctx context.Context, url string, file io.Writer) (int64, []byte, error)
```



<a name="DangerousInternalClient.DownloadPossiblyEncryptedMediaWithRetries"></a>
### func \(\*DangerousInternalClient\) DownloadPossiblyEncryptedMediaWithRetries

```go
func (int *DangerousInternalClient) DownloadPossiblyEncryptedMediaWithRetries(ctx context.Context, url string, checksum []byte) (file, mac []byte, err error)
```



<a name="DangerousInternalClient.DownloadPossiblyEncryptedMediaWithRetriesToFile"></a>
### func \(\*DangerousInternalClient\) DownloadPossiblyEncryptedMediaWithRetriesToFile

```go
func (int *DangerousInternalClient) DownloadPossiblyEncryptedMediaWithRetriesToFile(ctx context.Context, url string, checksum []byte, file File) (mac []byte, err error)
```



<a name="DangerousInternalClient.EncryptMessageForDevice"></a>
### func \(\*DangerousInternalClient\) EncryptMessageForDevice

```go
func (int *DangerousInternalClient) EncryptMessageForDevice(ctx context.Context, plaintext []byte, to types.JID, bundle *prekey.Bundle, extraAttrs waBinary.Attrs, existingSessions map[string]bool) (*waBinary.Node, bool, error)
```



<a name="DangerousInternalClient.EncryptMessageForDeviceAndWrap"></a>
### func \(\*DangerousInternalClient\) EncryptMessageForDeviceAndWrap

```go
func (int *DangerousInternalClient) EncryptMessageForDeviceAndWrap(ctx context.Context, plaintext []byte, wireIdentity, encryptionIdentity types.JID, bundle *prekey.Bundle, encAttrs waBinary.Attrs, existingSessions map[string]bool) (*waBinary.Node, bool, error)
```



<a name="DangerousInternalClient.EncryptMessageForDeviceAndWrapV3"></a>
### func \(\*DangerousInternalClient\) EncryptMessageForDeviceAndWrapV3

```go
func (int *DangerousInternalClient) EncryptMessageForDeviceAndWrapV3(ctx context.Context, payload *waMsgTransport.MessageTransport_Payload, skdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage, dsm *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage, to types.JID, bundle *prekey.Bundle, encAttrs waBinary.Attrs) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.EncryptMessageForDeviceV3"></a>
### func \(\*DangerousInternalClient\) EncryptMessageForDeviceV3

```go
func (int *DangerousInternalClient) EncryptMessageForDeviceV3(ctx context.Context, payload *waMsgTransport.MessageTransport_Payload, skdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage, dsm *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage, to types.JID, bundle *prekey.Bundle, extraAttrs waBinary.Attrs) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.EncryptMessageForDevices"></a>
### func \(\*DangerousInternalClient\) EncryptMessageForDevices

```go
func (int *DangerousInternalClient) EncryptMessageForDevices(ctx context.Context, allDevices []types.JID, id string, msgPlaintext, dsmPlaintext []byte, encAttrs waBinary.Attrs) ([]waBinary.Node, bool, error)
```



<a name="DangerousInternalClient.EncryptMessageForDevicesV3"></a>
### func \(\*DangerousInternalClient\) EncryptMessageForDevicesV3

```go
func (int *DangerousInternalClient) EncryptMessageForDevicesV3(ctx context.Context, allDevices []types.JID, ownID types.JID, id string, payload *waMsgTransport.MessageTransport_Payload, skdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage, dsm *waMsgTransport.MessageTransport_Protocol_Integral_DeviceSentMessage, encAttrs waBinary.Attrs) ([]waBinary.Node, error)
```



<a name="DangerousInternalClient.EncryptMsgSecret"></a>
### func \(\*DangerousInternalClient\) EncryptMsgSecret

```go
func (int *DangerousInternalClient) EncryptMsgSecret(ctx context.Context, ownID, chat, origSender types.JID, origMsgID types.MessageID, useCase MsgSecretType, plaintext []byte) (ciphertext, iv []byte, err error)
```



<a name="DangerousInternalClient.ExpectDisconnect"></a>
### func \(\*DangerousInternalClient\) ExpectDisconnect

```go
func (int *DangerousInternalClient) ExpectDisconnect()
```



<a name="DangerousInternalClient.FetchAppState"></a>
### func \(\*DangerousInternalClient\) FetchAppState

```go
func (int *DangerousInternalClient) FetchAppState(ctx context.Context, name appstate.WAPatchName, fullSync, onlyIfNotSynced bool) ([]any, error)
```



<a name="DangerousInternalClient.FetchAppStatePatches"></a>
### func \(\*DangerousInternalClient\) FetchAppStatePatches

```go
func (int *DangerousInternalClient) FetchAppStatePatches(ctx context.Context, name appstate.WAPatchName, fromVersion uint64, snapshot bool) (*appstate.PatchList, error)
```



<a name="DangerousInternalClient.FetchPreKeys"></a>
### func \(\*DangerousInternalClient\) FetchPreKeys

```go
func (int *DangerousInternalClient) FetchPreKeys(ctx context.Context, users []types.JID) (map[types.JID]preKeyResp, error)
```



<a name="DangerousInternalClient.FetchPreKeysNoError"></a>
### func \(\*DangerousInternalClient\) FetchPreKeysNoError

```go
func (int *DangerousInternalClient) FetchPreKeysNoError(ctx context.Context, retryDevices []types.JID) map[types.JID]*prekey.Bundle
```



<a name="DangerousInternalClient.FilterContacts"></a>
### func \(\*DangerousInternalClient\) FilterContacts

```go
func (int *DangerousInternalClient) FilterContacts(mutations []appstate.Mutation) ([]appstate.Mutation, []store.ContactEntry)
```



<a name="DangerousInternalClient.GenerateRequestID"></a>
### func \(\*DangerousInternalClient\) GenerateRequestID

```go
func (int *DangerousInternalClient) GenerateRequestID() string
```



<a name="DangerousInternalClient.GetBroadcastListParticipants"></a>
### func \(\*DangerousInternalClient\) GetBroadcastListParticipants

```go
func (int *DangerousInternalClient) GetBroadcastListParticipants(ctx context.Context, jid types.JID) ([]types.JID, error)
```



<a name="DangerousInternalClient.GetCachedGroupData"></a>
### func \(\*DangerousInternalClient\) GetCachedGroupData

```go
func (int *DangerousInternalClient) GetCachedGroupData(ctx context.Context, jid types.JID) (*groupMetaCache, error)
```



<a name="DangerousInternalClient.GetFBIDDevices"></a>
### func \(\*DangerousInternalClient\) GetFBIDDevices

```go
func (int *DangerousInternalClient) GetFBIDDevices(ctx context.Context, jids []types.JID) ([]types.JID, error)
```



<a name="DangerousInternalClient.GetFBIDDevicesInternal"></a>
### func \(\*DangerousInternalClient\) GetFBIDDevicesInternal

```go
func (int *DangerousInternalClient) GetFBIDDevicesInternal(ctx context.Context, jids []types.JID) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.GetGroupInfo"></a>
### func \(\*DangerousInternalClient\) GetGroupInfo

```go
func (int *DangerousInternalClient) GetGroupInfo(ctx context.Context, jid types.JID, lockParticipantCache bool) (*types.GroupInfo, error)
```



<a name="DangerousInternalClient.GetMessageContent"></a>
### func \(\*DangerousInternalClient\) GetMessageContent

```go
func (int *DangerousInternalClient) GetMessageContent(baseNode waBinary.Node, message *waE2E.Message, msgAttrs waBinary.Attrs, includeIdentity bool, extraParams nodeExtraParams) []waBinary.Node
```



<a name="DangerousInternalClient.GetMessageForRetry"></a>
### func \(\*DangerousInternalClient\) GetMessageForRetry

```go
func (int *DangerousInternalClient) GetMessageForRetry(ctx context.Context, receipt *events.Receipt, messageID types.MessageID) (RecentMessage, error)
```



<a name="DangerousInternalClient.GetMessageReportingToken"></a>
### func \(\*DangerousInternalClient\) GetMessageReportingToken

```go
func (int *DangerousInternalClient) GetMessageReportingToken(msgProtobuf []byte, msg *waE2E.Message, senderJID, remoteJID types.JID, messageID types.MessageID) waBinary.Node
```



<a name="DangerousInternalClient.GetNewsletterInfo"></a>
### func \(\*DangerousInternalClient\) GetNewsletterInfo

```go
func (int *DangerousInternalClient) GetNewsletterInfo(ctx context.Context, input map[string]any, fetchViewerMeta bool) (*types.NewsletterMetadata, error)
```



<a name="DangerousInternalClient.GetOwnID"></a>
### func \(\*DangerousInternalClient\) GetOwnID

```go
func (int *DangerousInternalClient) GetOwnID() types.JID
```



<a name="DangerousInternalClient.GetOwnLID"></a>
### func \(\*DangerousInternalClient\) GetOwnLID

```go
func (int *DangerousInternalClient) GetOwnLID() types.JID
```



<a name="DangerousInternalClient.GetRecentMessage"></a>
### func \(\*DangerousInternalClient\) GetRecentMessage

```go
func (int *DangerousInternalClient) GetRecentMessage(to types.JID, id types.MessageID) RecentMessage
```



<a name="DangerousInternalClient.GetServerPreKeyCount"></a>
### func \(\*DangerousInternalClient\) GetServerPreKeyCount

```go
func (int *DangerousInternalClient) GetServerPreKeyCount(ctx context.Context) (int, error)
```



<a name="DangerousInternalClient.GetSocketWaitChan"></a>
### func \(\*DangerousInternalClient\) GetSocketWaitChan

```go
func (int *DangerousInternalClient) GetSocketWaitChan() <-chan struct{}
```



<a name="DangerousInternalClient.GetStatusBroadcastRecipients"></a>
### func \(\*DangerousInternalClient\) GetStatusBroadcastRecipients

```go
func (int *DangerousInternalClient) GetStatusBroadcastRecipients(ctx context.Context) ([]types.JID, error)
```



<a name="DangerousInternalClient.HandleAccountSyncNotification"></a>
### func \(\*DangerousInternalClient\) HandleAccountSyncNotification

```go
func (int *DangerousInternalClient) HandleAccountSyncNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleAppStateNotification"></a>
### func \(\*DangerousInternalClient\) HandleAppStateNotification

```go
func (int *DangerousInternalClient) HandleAppStateNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleAppStateSyncKeyShare"></a>
### func \(\*DangerousInternalClient\) HandleAppStateSyncKeyShare

```go
func (int *DangerousInternalClient) HandleAppStateSyncKeyShare(ctx context.Context, keys *waE2E.AppStateSyncKeyShare)
```



<a name="DangerousInternalClient.HandleBlocklist"></a>
### func \(\*DangerousInternalClient\) HandleBlocklist

```go
func (int *DangerousInternalClient) HandleBlocklist(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleCallEvent"></a>
### func \(\*DangerousInternalClient\) HandleCallEvent

```go
func (int *DangerousInternalClient) HandleCallEvent(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleChatState"></a>
### func \(\*DangerousInternalClient\) HandleChatState

```go
func (int *DangerousInternalClient) HandleChatState(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleCodePairNotification"></a>
### func \(\*DangerousInternalClient\) HandleCodePairNotification

```go
func (int *DangerousInternalClient) HandleCodePairNotification(ctx context.Context, parentNode *waBinary.Node) error
```



<a name="DangerousInternalClient.HandleConnectFailure"></a>
### func \(\*DangerousInternalClient\) HandleConnectFailure

```go
func (int *DangerousInternalClient) HandleConnectFailure(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleConnectSuccess"></a>
### func \(\*DangerousInternalClient\) HandleConnectSuccess

```go
func (int *DangerousInternalClient) HandleConnectSuccess(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleDecryptedArmadillo"></a>
### func \(\*DangerousInternalClient\) HandleDecryptedArmadillo

```go
func (int *DangerousInternalClient) HandleDecryptedArmadillo(ctx context.Context, info *types.MessageInfo, decrypted []byte, retryCount int) (handlerFailed, protobufFailed bool)
```



<a name="DangerousInternalClient.HandleDecryptedMessage"></a>
### func \(\*DangerousInternalClient\) HandleDecryptedMessage

```go
func (int *DangerousInternalClient) HandleDecryptedMessage(ctx context.Context, info *types.MessageInfo, msg *waE2E.Message, retryCount int) bool
```



<a name="DangerousInternalClient.HandleDeviceNotification"></a>
### func \(\*DangerousInternalClient\) HandleDeviceNotification

```go
func (int *DangerousInternalClient) HandleDeviceNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleEncryptNotification"></a>
### func \(\*DangerousInternalClient\) HandleEncryptNotification

```go
func (int *DangerousInternalClient) HandleEncryptNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleEncryptedMessage"></a>
### func \(\*DangerousInternalClient\) HandleEncryptedMessage

```go
func (int *DangerousInternalClient) HandleEncryptedMessage(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleFBDeviceNotification"></a>
### func \(\*DangerousInternalClient\) HandleFBDeviceNotification

```go
func (int *DangerousInternalClient) HandleFBDeviceNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleFrame"></a>
### func \(\*DangerousInternalClient\) HandleFrame

```go
func (int *DangerousInternalClient) HandleFrame(ctx context.Context, data []byte)
```



<a name="DangerousInternalClient.HandleGroupedReceipt"></a>
### func \(\*DangerousInternalClient\) HandleGroupedReceipt

```go
func (int *DangerousInternalClient) HandleGroupedReceipt(partialReceipt events.Receipt, participants *waBinary.Node)
```



<a name="DangerousInternalClient.HandleHistoricalPushNames"></a>
### func \(\*DangerousInternalClient\) HandleHistoricalPushNames

```go
func (int *DangerousInternalClient) HandleHistoricalPushNames(ctx context.Context, names []*waHistorySync.Pushname)
```



<a name="DangerousInternalClient.HandleHistorySyncNotificationLoop"></a>
### func \(\*DangerousInternalClient\) HandleHistorySyncNotificationLoop

```go
func (int *DangerousInternalClient) HandleHistorySyncNotificationLoop()
```



<a name="DangerousInternalClient.HandleIB"></a>
### func \(\*DangerousInternalClient\) HandleIB

```go
func (int *DangerousInternalClient) HandleIB(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleIQ"></a>
### func \(\*DangerousInternalClient\) HandleIQ

```go
func (int *DangerousInternalClient) HandleIQ(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleMediaRetryNotification"></a>
### func \(\*DangerousInternalClient\) HandleMediaRetryNotification

```go
func (int *DangerousInternalClient) HandleMediaRetryNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleMexNotification"></a>
### func \(\*DangerousInternalClient\) HandleMexNotification

```go
func (int *DangerousInternalClient) HandleMexNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleNewsletterNotification"></a>
### func \(\*DangerousInternalClient\) HandleNewsletterNotification

```go
func (int *DangerousInternalClient) HandleNewsletterNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleNotification"></a>
### func \(\*DangerousInternalClient\) HandleNotification

```go
func (int *DangerousInternalClient) HandleNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleOwnDevicesNotification"></a>
### func \(\*DangerousInternalClient\) HandleOwnDevicesNotification

```go
func (int *DangerousInternalClient) HandleOwnDevicesNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandlePair"></a>
### func \(\*DangerousInternalClient\) HandlePair

```go
func (int *DangerousInternalClient) HandlePair(ctx context.Context, deviceIdentityBytes []byte, reqID, businessName, platform string, jid, lid types.JID) error
```



<a name="DangerousInternalClient.HandlePairDevice"></a>
### func \(\*DangerousInternalClient\) HandlePairDevice

```go
func (int *DangerousInternalClient) HandlePairDevice(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandlePairSuccess"></a>
### func \(\*DangerousInternalClient\) HandlePairSuccess

```go
func (int *DangerousInternalClient) HandlePairSuccess(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandlePictureNotification"></a>
### func \(\*DangerousInternalClient\) HandlePictureNotification

```go
func (int *DangerousInternalClient) HandlePictureNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandlePlaceholderResendResponse"></a>
### func \(\*DangerousInternalClient\) HandlePlaceholderResendResponse

```go
func (int *DangerousInternalClient) HandlePlaceholderResendResponse(msg *waE2E.PeerDataOperationRequestResponseMessage) (ok bool)
```



<a name="DangerousInternalClient.HandlePlaintextMessage"></a>
### func \(\*DangerousInternalClient\) HandlePlaintextMessage

```go
func (int *DangerousInternalClient) HandlePlaintextMessage(ctx context.Context, info *types.MessageInfo, node *waBinary.Node) (handlerFailed bool)
```



<a name="DangerousInternalClient.HandlePresence"></a>
### func \(\*DangerousInternalClient\) HandlePresence

```go
func (int *DangerousInternalClient) HandlePresence(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandlePrivacySettingsNotification"></a>
### func \(\*DangerousInternalClient\) HandlePrivacySettingsNotification

```go
func (int *DangerousInternalClient) HandlePrivacySettingsNotification(ctx context.Context, privacyNode *waBinary.Node)
```



<a name="DangerousInternalClient.HandlePrivacyTokenNotification"></a>
### func \(\*DangerousInternalClient\) HandlePrivacyTokenNotification

```go
func (int *DangerousInternalClient) HandlePrivacyTokenNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleProtocolMessage"></a>
### func \(\*DangerousInternalClient\) HandleProtocolMessage

```go
func (int *DangerousInternalClient) HandleProtocolMessage(ctx context.Context, info *types.MessageInfo, msg *waE2E.Message) (ok bool)
```



<a name="DangerousInternalClient.HandleReceipt"></a>
### func \(\*DangerousInternalClient\) HandleReceipt

```go
func (int *DangerousInternalClient) HandleReceipt(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleRetryReceipt"></a>
### func \(\*DangerousInternalClient\) HandleRetryReceipt

```go
func (int *DangerousInternalClient) HandleRetryReceipt(ctx context.Context, receipt *events.Receipt, node *waBinary.Node) error
```



<a name="DangerousInternalClient.HandleSenderKeyDistributionMessage"></a>
### func \(\*DangerousInternalClient\) HandleSenderKeyDistributionMessage

```go
func (int *DangerousInternalClient) HandleSenderKeyDistributionMessage(ctx context.Context, chat, from types.JID, axolotlSKDM []byte)
```



<a name="DangerousInternalClient.HandleStatusNotification"></a>
### func \(\*DangerousInternalClient\) HandleStatusNotification

```go
func (int *DangerousInternalClient) HandleStatusNotification(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandleStreamError"></a>
### func \(\*DangerousInternalClient\) HandleStreamError

```go
func (int *DangerousInternalClient) HandleStreamError(ctx context.Context, node *waBinary.Node)
```



<a name="DangerousInternalClient.HandlerQueueLoop"></a>
### func \(\*DangerousInternalClient\) HandlerQueueLoop

```go
func (int *DangerousInternalClient) HandlerQueueLoop(evtCtx, connCtx context.Context)
```



<a name="DangerousInternalClient.ImmediateRequestMessageFromPhone"></a>
### func \(\*DangerousInternalClient\) ImmediateRequestMessageFromPhone

```go
func (int *DangerousInternalClient) ImmediateRequestMessageFromPhone(ctx context.Context, info *types.MessageInfo)
```



<a name="DangerousInternalClient.IsExpectedDisconnect"></a>
### func \(\*DangerousInternalClient\) IsExpectedDisconnect

```go
func (int *DangerousInternalClient) IsExpectedDisconnect() bool
```



<a name="DangerousInternalClient.KeepAliveLoop"></a>
### func \(\*DangerousInternalClient\) KeepAliveLoop

```go
func (int *DangerousInternalClient) KeepAliveLoop(ctx, connCtx context.Context)
```



<a name="DangerousInternalClient.MakeDeviceIdentityNode"></a>
### func \(\*DangerousInternalClient\) MakeDeviceIdentityNode

```go
func (int *DangerousInternalClient) MakeDeviceIdentityNode() waBinary.Node
```



<a name="DangerousInternalClient.MakeQRData"></a>
### func \(\*DangerousInternalClient\) MakeQRData

```go
func (int *DangerousInternalClient) MakeQRData(ref string) string
```



<a name="DangerousInternalClient.MaybeDeferredAck"></a>
### func \(\*DangerousInternalClient\) MaybeDeferredAck

```go
func (int *DangerousInternalClient) MaybeDeferredAck(ctx context.Context, node *waBinary.Node) func(...*bool)
```



<a name="DangerousInternalClient.MigrateSessionStore"></a>
### func \(\*DangerousInternalClient\) MigrateSessionStore

```go
func (int *DangerousInternalClient) MigrateSessionStore(ctx context.Context, pn, lid types.JID)
```



<a name="DangerousInternalClient.OnDisconnect"></a>
### func \(\*DangerousInternalClient\) OnDisconnect

```go
func (int *DangerousInternalClient) OnDisconnect(ctx context.Context, ns *socket.NoiseSocket, remote bool)
```



<a name="DangerousInternalClient.ParseBlocklist"></a>
### func \(\*DangerousInternalClient\) ParseBlocklist

```go
func (int *DangerousInternalClient) ParseBlocklist(node *waBinary.Node) *types.Blocklist
```



<a name="DangerousInternalClient.ParseBusinessProfile"></a>
### func \(\*DangerousInternalClient\) ParseBusinessProfile

```go
func (int *DangerousInternalClient) ParseBusinessProfile(node *waBinary.Node) (*types.BusinessProfile, error)
```



<a name="DangerousInternalClient.ParseGroupChange"></a>
### func \(\*DangerousInternalClient\) ParseGroupChange

```go
func (int *DangerousInternalClient) ParseGroupChange(node *waBinary.Node) (*events.GroupInfo, []store.LIDMapping, error)
```



<a name="DangerousInternalClient.ParseGroupCreate"></a>
### func \(\*DangerousInternalClient\) ParseGroupCreate

```go
func (int *DangerousInternalClient) ParseGroupCreate(parentNode, node *waBinary.Node) (*events.JoinedGroup, []store.LIDMapping, []store.RedactedPhoneEntry, error)
```



<a name="DangerousInternalClient.ParseGroupNode"></a>
### func \(\*DangerousInternalClient\) ParseGroupNode

```go
func (int *DangerousInternalClient) ParseGroupNode(groupNode *waBinary.Node) (*types.GroupInfo, error)
```



<a name="DangerousInternalClient.ParseGroupNotification"></a>
### func \(\*DangerousInternalClient\) ParseGroupNotification

```go
func (int *DangerousInternalClient) ParseGroupNotification(node *waBinary.Node) (any, []store.LIDMapping, []store.RedactedPhoneEntry, error)
```



<a name="DangerousInternalClient.ParseMessageInfo"></a>
### func \(\*DangerousInternalClient\) ParseMessageInfo

```go
func (int *DangerousInternalClient) ParseMessageInfo(node *waBinary.Node) (*types.MessageInfo, error)
```



<a name="DangerousInternalClient.ParseMessageSource"></a>
### func \(\*DangerousInternalClient\) ParseMessageSource

```go
func (int *DangerousInternalClient) ParseMessageSource(node *waBinary.Node, requireParticipant bool) (source types.MessageSource, err error)
```



<a name="DangerousInternalClient.ParseMsgBotInfo"></a>
### func \(\*DangerousInternalClient\) ParseMsgBotInfo

```go
func (int *DangerousInternalClient) ParseMsgBotInfo(node waBinary.Node) (botInfo types.MsgBotInfo, err error)
```



<a name="DangerousInternalClient.ParseMsgMetaInfo"></a>
### func \(\*DangerousInternalClient\) ParseMsgMetaInfo

```go
func (int *DangerousInternalClient) ParseMsgMetaInfo(node waBinary.Node) (metaInfo types.MsgMetaInfo, err error)
```



<a name="DangerousInternalClient.ParseNewsletterMessages"></a>
### func \(\*DangerousInternalClient\) ParseNewsletterMessages

```go
func (int *DangerousInternalClient) ParseNewsletterMessages(node *waBinary.Node) []*types.NewsletterMessage
```



<a name="DangerousInternalClient.ParsePrivacySettings"></a>
### func \(\*DangerousInternalClient\) ParsePrivacySettings

```go
func (int *DangerousInternalClient) ParsePrivacySettings(privacyNode *waBinary.Node, settings *types.PrivacySettings) *events.PrivacySettings
```



<a name="DangerousInternalClient.ParseReceipt"></a>
### func \(\*DangerousInternalClient\) ParseReceipt

```go
func (int *DangerousInternalClient) ParseReceipt(node *waBinary.Node) (*events.Receipt, error)
```



<a name="DangerousInternalClient.PrepareMessageNode"></a>
### func \(\*DangerousInternalClient\) PrepareMessageNode

```go
func (int *DangerousInternalClient) PrepareMessageNode(ctx context.Context, to types.JID, id types.MessageID, message *waE2E.Message, participants []types.JID, plaintext, dsmPlaintext []byte, timings *MessageDebugTimings, extraParams nodeExtraParams) (*waBinary.Node, []types.JID, error)
```



<a name="DangerousInternalClient.PrepareMessageNodeV3"></a>
### func \(\*DangerousInternalClient\) PrepareMessageNodeV3

```go
func (int *DangerousInternalClient) PrepareMessageNodeV3(ctx context.Context, to, ownID types.JID, id types.MessageID, payload *waMsgTransport.MessageTransport_Payload, skdm *waMsgTransport.MessageTransport_Protocol_Ancillary_SenderKeyDistributionMessage, msgAttrs messageAttrs, frankingTag []byte, participants []types.JID, timings *MessageDebugTimings) (*waBinary.Node, []types.JID, error)
```



<a name="DangerousInternalClient.PreparePeerMessageNode"></a>
### func \(\*DangerousInternalClient\) PreparePeerMessageNode

```go
func (int *DangerousInternalClient) PreparePeerMessageNode(ctx context.Context, to types.JID, id types.MessageID, message *waE2E.Message, timings *MessageDebugTimings) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.ProcessProtocolParts"></a>
### func \(\*DangerousInternalClient\) ProcessProtocolParts

```go
func (int *DangerousInternalClient) ProcessProtocolParts(ctx context.Context, info *types.MessageInfo, msg *waE2E.Message) (ok bool)
```



<a name="DangerousInternalClient.QueryMediaConn"></a>
### func \(\*DangerousInternalClient\) QueryMediaConn

```go
func (int *DangerousInternalClient) QueryMediaConn(ctx context.Context) (*MediaConn, error)
```



<a name="DangerousInternalClient.RawUpload"></a>
### func \(\*DangerousInternalClient\) RawUpload

```go
func (int *DangerousInternalClient) RawUpload(ctx context.Context, dataToUpload io.Reader, uploadSize uint64, fileHash []byte, appInfo MediaType, newsletter bool, resp *UploadResponse) error
```



<a name="DangerousInternalClient.ReceiveResponse"></a>
### func \(\*DangerousInternalClient\) ReceiveResponse

```go
func (int *DangerousInternalClient) ReceiveResponse(ctx context.Context, data *waBinary.Node) bool
```



<a name="DangerousInternalClient.RefreshMediaConn"></a>
### func \(\*DangerousInternalClient\) RefreshMediaConn

```go
func (int *DangerousInternalClient) RefreshMediaConn(ctx context.Context, force bool) (*MediaConn, error)
```



<a name="DangerousInternalClient.RequestAppStateKeys"></a>
### func \(\*DangerousInternalClient\) RequestAppStateKeys

```go
func (int *DangerousInternalClient) RequestAppStateKeys(ctx context.Context, rawKeyIDs [][]byte)
```



<a name="DangerousInternalClient.RequestMissingAppStateKeys"></a>
### func \(\*DangerousInternalClient\) RequestMissingAppStateKeys

```go
func (int *DangerousInternalClient) RequestMissingAppStateKeys(ctx context.Context, patches *appstate.PatchList)
```



<a name="DangerousInternalClient.ResetExpectedDisconnect"></a>
### func \(\*DangerousInternalClient\) ResetExpectedDisconnect

```go
func (int *DangerousInternalClient) ResetExpectedDisconnect()
```



<a name="DangerousInternalClient.RetryFrame"></a>
### func \(\*DangerousInternalClient\) RetryFrame

```go
func (int *DangerousInternalClient) RetryFrame(ctx context.Context, reqType, id string, data []byte, origResp *waBinary.Node, timeout time.Duration) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.SendAck"></a>
### func \(\*DangerousInternalClient\) SendAck

```go
func (int *DangerousInternalClient) SendAck(ctx context.Context, node *waBinary.Node, error int)
```



<a name="DangerousInternalClient.SendAppState"></a>
### func \(\*DangerousInternalClient\) SendAppState

```go
func (int *DangerousInternalClient) SendAppState(ctx context.Context, patch appstate.PatchInfo, allowRetry bool) error
```



<a name="DangerousInternalClient.SendDM"></a>
### func \(\*DangerousInternalClient\) SendDM

```go
func (int *DangerousInternalClient) SendDM(ctx context.Context, ownID, to types.JID, id types.MessageID, message *waE2E.Message, timings *MessageDebugTimings, extraParams nodeExtraParams) (string, []byte, error)
```



<a name="DangerousInternalClient.SendDMV3"></a>
### func \(\*DangerousInternalClient\) SendDMV3

```go
func (int *DangerousInternalClient) SendDMV3(ctx context.Context, to, ownID types.JID, id types.MessageID, messageApp []byte, msgAttrs messageAttrs, frankingTag []byte, timings *MessageDebugTimings) ([]byte, string, error)
```



<a name="DangerousInternalClient.SendGroup"></a>
### func \(\*DangerousInternalClient\) SendGroup

```go
func (int *DangerousInternalClient) SendGroup(ctx context.Context, ownID, to types.JID, participants []types.JID, id types.MessageID, message *waE2E.Message, timings *MessageDebugTimings, extraParams nodeExtraParams) (string, []byte, error)
```



<a name="DangerousInternalClient.SendGroupIQ"></a>
### func \(\*DangerousInternalClient\) SendGroupIQ

```go
func (int *DangerousInternalClient) SendGroupIQ(ctx context.Context, iqType infoQueryType, jid types.JID, content waBinary.Node) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.SendGroupV3"></a>
### func \(\*DangerousInternalClient\) SendGroupV3

```go
func (int *DangerousInternalClient) SendGroupV3(ctx context.Context, to, ownID types.JID, id types.MessageID, messageApp []byte, msgAttrs messageAttrs, frankingTag []byte, timings *MessageDebugTimings) (string, []byte, error)
```



<a name="DangerousInternalClient.SendIQ"></a>
### func \(\*DangerousInternalClient\) SendIQ

```go
func (int *DangerousInternalClient) SendIQ(ctx context.Context, query infoQuery) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.SendIQAsync"></a>
### func \(\*DangerousInternalClient\) SendIQAsync

```go
func (int *DangerousInternalClient) SendIQAsync(ctx context.Context, query infoQuery) (<-chan *waBinary.Node, error)
```



<a name="DangerousInternalClient.SendIQAsyncAndGetData"></a>
### func \(\*DangerousInternalClient\) SendIQAsyncAndGetData

```go
func (int *DangerousInternalClient) SendIQAsyncAndGetData(ctx context.Context, query *infoQuery) (<-chan *waBinary.Node, []byte, error)
```



<a name="DangerousInternalClient.SendKeepAlive"></a>
### func \(\*DangerousInternalClient\) SendKeepAlive

```go
func (int *DangerousInternalClient) SendKeepAlive(ctx context.Context) (isSuccess, shouldContinue bool)
```



<a name="DangerousInternalClient.SendMessageReceipt"></a>
### func \(\*DangerousInternalClient\) SendMessageReceipt

```go
func (int *DangerousInternalClient) SendMessageReceipt(ctx context.Context, info *types.MessageInfo, node *waBinary.Node)
```



<a name="DangerousInternalClient.SendMexIQ"></a>
### func \(\*DangerousInternalClient\) SendMexIQ

```go
func (int *DangerousInternalClient) SendMexIQ(ctx context.Context, queryID string, variables any) (json.RawMessage, error)
```



<a name="DangerousInternalClient.SendNewsletter"></a>
### func \(\*DangerousInternalClient\) SendNewsletter

```go
func (int *DangerousInternalClient) SendNewsletter(ctx context.Context, to types.JID, id types.MessageID, message *waE2E.Message, mediaID string, timings *MessageDebugTimings) ([]byte, error)
```



<a name="DangerousInternalClient.SendNode"></a>
### func \(\*DangerousInternalClient\) SendNode

```go
func (int *DangerousInternalClient) SendNode(ctx context.Context, node waBinary.Node) error
```



<a name="DangerousInternalClient.SendNodeAndGetData"></a>
### func \(\*DangerousInternalClient\) SendNodeAndGetData

```go
func (int *DangerousInternalClient) SendNodeAndGetData(ctx context.Context, node waBinary.Node) ([]byte, error)
```



<a name="DangerousInternalClient.SendPairError"></a>
### func \(\*DangerousInternalClient\) SendPairError

```go
func (int *DangerousInternalClient) SendPairError(ctx context.Context, id string, code int, text string)
```



<a name="DangerousInternalClient.SendPeerMessage"></a>
### func \(\*DangerousInternalClient\) SendPeerMessage

```go
func (int *DangerousInternalClient) SendPeerMessage(ctx context.Context, to types.JID, id types.MessageID, message *waE2E.Message, timings *MessageDebugTimings) ([]byte, error)
```



<a name="DangerousInternalClient.SendProtocolMessageReceipt"></a>
### func \(\*DangerousInternalClient\) SendProtocolMessageReceipt

```go
func (int *DangerousInternalClient) SendProtocolMessageReceipt(ctx context.Context, id types.MessageID, msgType types.ReceiptType)
```



<a name="DangerousInternalClient.SendRetryReceipt"></a>
### func \(\*DangerousInternalClient\) SendRetryReceipt

```go
func (int *DangerousInternalClient) SendRetryReceipt(ctx context.Context, node *waBinary.Node, info *types.MessageInfo, forceIncludeIdentity bool)
```



<a name="DangerousInternalClient.SetTransport"></a>
### func \(\*DangerousInternalClient\) SetTransport

```go
func (int *DangerousInternalClient) SetTransport(transport *http.Transport, opt SetProxyOptions)
```



<a name="DangerousInternalClient.ShouldIncludeReportingToken"></a>
### func \(\*DangerousInternalClient\) ShouldIncludeReportingToken

```go
func (int *DangerousInternalClient) ShouldIncludeReportingToken(message *waE2E.Message) bool
```



<a name="DangerousInternalClient.ShouldRecreateSession"></a>
### func \(\*DangerousInternalClient\) ShouldRecreateSession

```go
func (int *DangerousInternalClient) ShouldRecreateSession(ctx context.Context, retryCount int, jid types.JID) (reason string, recreate bool)
```



<a name="DangerousInternalClient.StoreGlobalSettings"></a>
### func \(\*DangerousInternalClient\) StoreGlobalSettings

```go
func (int *DangerousInternalClient) StoreGlobalSettings(ctx context.Context, settings *waHistorySync.GlobalSettings)
```



<a name="DangerousInternalClient.StoreHistoricalMessageSecrets"></a>
### func \(\*DangerousInternalClient\) StoreHistoricalMessageSecrets

```go
func (int *DangerousInternalClient) StoreHistoricalMessageSecrets(ctx context.Context, conversations []*waHistorySync.Conversation)
```



<a name="DangerousInternalClient.StoreHistoricalPNLIDMappings"></a>
### func \(\*DangerousInternalClient\) StoreHistoricalPNLIDMappings

```go
func (int *DangerousInternalClient) StoreHistoricalPNLIDMappings(ctx context.Context, mappings []*waHistorySync.PhoneNumberToLIDMapping)
```



<a name="DangerousInternalClient.StoreLIDSyncMessage"></a>
### func \(\*DangerousInternalClient\) StoreLIDSyncMessage

```go
func (int *DangerousInternalClient) StoreLIDSyncMessage(ctx context.Context, msg []byte)
```



<a name="DangerousInternalClient.StoreMessageSecret"></a>
### func \(\*DangerousInternalClient\) StoreMessageSecret

```go
func (int *DangerousInternalClient) StoreMessageSecret(ctx context.Context, info *types.MessageInfo, msg *waE2E.Message)
```



<a name="DangerousInternalClient.TryHandleCodePairNotification"></a>
### func \(\*DangerousInternalClient\) TryHandleCodePairNotification

```go
func (int *DangerousInternalClient) TryHandleCodePairNotification(ctx context.Context, parentNode *waBinary.Node)
```



<a name="DangerousInternalClient.UnlockedConnect"></a>
### func \(\*DangerousInternalClient\) UnlockedConnect

```go
func (int *DangerousInternalClient) UnlockedConnect(ctx context.Context) error
```



<a name="DangerousInternalClient.UnlockedDisconnect"></a>
### func \(\*DangerousInternalClient\) UnlockedDisconnect

```go
func (int *DangerousInternalClient) UnlockedDisconnect()
```



<a name="DangerousInternalClient.UpdateBusinessName"></a>
### func \(\*DangerousInternalClient\) UpdateBusinessName

```go
func (int *DangerousInternalClient) UpdateBusinessName(ctx context.Context, user, userAlt types.JID, messageInfo *types.MessageInfo, name string)
```



<a name="DangerousInternalClient.UpdateGroupParticipantCache"></a>
### func \(\*DangerousInternalClient\) UpdateGroupParticipantCache

```go
func (int *DangerousInternalClient) UpdateGroupParticipantCache(evt *events.GroupInfo)
```



<a name="DangerousInternalClient.UpdatePushName"></a>
### func \(\*DangerousInternalClient\) UpdatePushName

```go
func (int *DangerousInternalClient) UpdatePushName(ctx context.Context, user, userAlt types.JID, messageInfo *types.MessageInfo, name string)
```



<a name="DangerousInternalClient.UploadPreKeys"></a>
### func \(\*DangerousInternalClient\) UploadPreKeys

```go
func (int *DangerousInternalClient) UploadPreKeys(ctx context.Context, initialUpload bool)
```



<a name="DangerousInternalClient.Usync"></a>
### func \(\*DangerousInternalClient\) Usync

```go
func (int *DangerousInternalClient) Usync(ctx context.Context, jids []types.JID, mode, context string, query []waBinary.Node, extra ...UsyncQueryExtras) (*waBinary.Node, error)
```



<a name="DangerousInternalClient.WaitResponse"></a>
### func \(\*DangerousInternalClient\) WaitResponse

```go
func (int *DangerousInternalClient) WaitResponse(reqID string) chan *waBinary.Node
```



<a name="DisconnectedError"></a>
## type DisconnectedError

DisconnectedError is returned if the websocket disconnects before an info query or other request gets a response.

```go
type DisconnectedError struct {
    Action string
    Node   *waBinary.Node
}
```

<a name="DisconnectedError.Error"></a>
### func \(\*DisconnectedError\) Error

```go
func (err *DisconnectedError) Error() string
```



<a name="DisconnectedError.Is"></a>
### func \(\*DisconnectedError\) Is

```go
func (err *DisconnectedError) Is(other error) bool
```



<a name="DownloadHTTPError"></a>
## type DownloadHTTPError



```go
type DownloadHTTPError struct {
    *http.Response
}
```

<a name="DownloadHTTPError.Error"></a>
### func \(DownloadHTTPError\) Error

```go
func (dhe DownloadHTTPError) Error() string
```



<a name="DownloadHTTPError.Is"></a>
### func \(DownloadHTTPError\) Is

```go
func (dhe DownloadHTTPError) Is(other error) bool
```



<a name="DownloadableMessage"></a>
## type DownloadableMessage

DownloadableMessage represents a protobuf message that contains attachment info.

All of the downloadable messages inside a Message struct implement this interface \(ImageMessage, VideoMessage, AudioMessage, DocumentMessage, StickerMessage\).

```go
type DownloadableMessage interface {
    GetDirectPath() string
    GetMediaKey() []byte
    GetFileSHA256() []byte
    GetFileEncSHA256() []byte
}
```

<a name="DownloadableThumbnail"></a>
## type DownloadableThumbnail

DownloadableThumbnail represents a protobuf message that contains a thumbnail attachment.

This is primarily meant for link preview thumbnails in ExtendedTextMessage.

```go
type DownloadableThumbnail interface {
    proto.Message
    GetThumbnailDirectPath() string
    GetThumbnailSHA256() []byte
    GetThumbnailEncSHA256() []byte
    GetMediaKey() []byte
}
```

<a name="ElementMissingError"></a>
## type ElementMissingError

ElementMissingError is returned by various functions that parse XML elements when a required element is missing.

```go
type ElementMissingError struct {
    Tag string
    In  string
}
```

<a name="ElementMissingError.Error"></a>
### func \(\*ElementMissingError\) Error

```go
func (eme *ElementMissingError) Error() string
```



<a name="EventHandler"></a>
## type EventHandler

EventHandler is a function that can handle events from WhatsApp.

```go
type EventHandler func(evt any)
```

<a name="EventHandlerWithSuccessStatus"></a>
## type EventHandlerWithSuccessStatus



```go
type EventHandlerWithSuccessStatus func(evt any) bool
```

<a name="FCMPushConfig"></a>
## type FCMPushConfig



```go
type FCMPushConfig struct {
    Token string `json:"token"`
}
```

<a name="FCMPushConfig.GetPushConfigAttrs"></a>
### func \(\*FCMPushConfig\) GetPushConfigAttrs

```go
func (fpc *FCMPushConfig) GetPushConfigAttrs() waBinary.Attrs
```



<a name="File"></a>
## type File



```go
type File interface {
    io.Reader
    io.Writer
    io.Seeker
    io.ReaderAt
    io.WriterAt
    Truncate(size int64) error
    Stat() (os.FileInfo, error)
}
```

<a name="GetNewsletterMessagesParams"></a>
## type GetNewsletterMessagesParams



```go
type GetNewsletterMessagesParams struct {
    Count  int
    Before types.MessageServerID
}
```

<a name="GetNewsletterUpdatesParams"></a>
## type GetNewsletterUpdatesParams



```go
type GetNewsletterUpdatesParams struct {
    Count int
    Since time.Time
    After types.MessageServerID
}
```

<a name="GetProfilePictureParams"></a>
## type GetProfilePictureParams



```go
type GetProfilePictureParams struct {
    Preview     bool
    ExistingID  string
    IsCommunity bool
    // This is a common group ID that you share with the target
    CommonGID types.JID
    // use this to query the profile photo of a group you don't have joined, but you have an invite code for
    InviteCode string
    // Persona ID when getting profile of Meta AI bots
    PersonaID string
}
```

<a name="IQError"></a>
## type IQError

IQError is a generic error container for info queries

```go
type IQError struct {
    Code      int
    Text      string
    ErrorNode *waBinary.Node
    RawNode   *waBinary.Node
}
```

<a name="IQError.Error"></a>
### func \(\*IQError\) Error

```go
func (iqe *IQError) Error() string
```



<a name="IQError.Is"></a>
### func \(\*IQError\) Is

```go
func (iqe *IQError) Is(other error) bool
```



<a name="MediaConn"></a>
## type MediaConn

MediaConn contains a list of WhatsApp servers from which attachments can be downloaded from.

```go
type MediaConn struct {
    Auth       string
    AuthTTL    int
    TTL        int
    MaxBuckets int
    FetchedAt  time.Time
    Hosts      []MediaConnHost
}
```

<a name="MediaConn.Expiry"></a>
### func \(\*MediaConn\) Expiry

```go
func (mc *MediaConn) Expiry() time.Time
```

Expiry returns the time when the MediaConn expires.

<a name="MediaConnHost"></a>
## type MediaConnHost

MediaConnHost represents a single host to download media from.

```go
type MediaConnHost struct {
    Hostname string
}
```

<a name="MediaType"></a>
## type MediaType

MediaType represents a type of uploaded file on WhatsApp. The value is the key which is used as a part of generating the encryption keys.

```go
type MediaType string
```

<a name="MediaImage"></a>The known media types

```go
const (
    MediaImage    MediaType = "WhatsApp Image Keys"
    MediaVideo    MediaType = "WhatsApp Video Keys"
    MediaAudio    MediaType = "WhatsApp Audio Keys"
    MediaDocument MediaType = "WhatsApp Document Keys"
    MediaHistory  MediaType = "WhatsApp History Keys"
    MediaAppState MediaType = "WhatsApp App State Keys"

    MediaStickerPack   MediaType = "WhatsApp Sticker Pack Keys"
    MediaLinkThumbnail MediaType = "WhatsApp Link Thumbnail Keys"
)
```

<a name="GetMediaType"></a>
### func GetMediaType

```go
func GetMediaType(msg DownloadableMessage) MediaType
```

GetMediaType returns the MediaType value corresponding to the given protobuf message.

<a name="MediaTypeable"></a>
## type MediaTypeable



```go
type MediaTypeable interface {
    GetMediaType() MediaType
}
```

<a name="MessageDebugTimings"></a>
## type MessageDebugTimings



```go
type MessageDebugTimings struct {
    LIDFetch time.Duration
    Queue    time.Duration

    Marshal         time.Duration
    GetParticipants time.Duration
    GetDevices      time.Duration
    GroupEncrypt    time.Duration
    PeerEncrypt     time.Duration

    Send  time.Duration
    Resp  time.Duration
    Retry time.Duration
}
```

<a name="MessageDebugTimings.MarshalZerologObject"></a>
### func \(MessageDebugTimings\) MarshalZerologObject

```go
func (mdt MessageDebugTimings) MarshalZerologObject(evt *zerolog.Event)
```



<a name="MessengerConfig"></a>
## type MessengerConfig



```go
type MessengerConfig struct {
    UserAgent    string
    BaseURL      string
    WebsocketURL string
}
```

<a name="MsgSecretType"></a>
## type MsgSecretType



```go
type MsgSecretType string
```

<a name="EncSecretPollVote"></a>

```go
const (
    EncSecretPollVote      MsgSecretType = "Poll Vote"
    EncSecretReaction      MsgSecretType = "Enc Reaction"
    EncSecretComment       MsgSecretType = "Enc Comment"
    EncSecretReportToken   MsgSecretType = "Report Token"
    EncSecretEventResponse MsgSecretType = "Event Response"
    EncSecretEventEdit     MsgSecretType = "Event Edit"
    EncSecretBotMsg        MsgSecretType = "Bot Message"
)
```

<a name="PairClientType"></a>
## type PairClientType

PairClientType is the type of client to use with PairCode. The type is automatically filled based on store.DeviceProps.PlatformType \(which is what QR login uses\).

```go
type PairClientType int
```

<a name="PairClientUnknown"></a>

```go
const (
    PairClientUnknown PairClientType = iota
    PairClientChrome
    PairClientEdge
    PairClientFirefox
    PairClientIE
    PairClientOpera
    PairClientSafari
    PairClientElectron
    PairClientUWP
    PairClientOtherWebClient
)
```

<a name="PairDatabaseError"></a>
## type PairDatabaseError

PairDatabaseError is included in an events.PairError if the pairing failed due to being unable to save the credentials to the device store.

```go
type PairDatabaseError struct {
    Message string
    DBErr   error
}
```

<a name="PairDatabaseError.Error"></a>
### func \(\*PairDatabaseError\) Error

```go
func (err *PairDatabaseError) Error() string
```



<a name="PairDatabaseError.Unwrap"></a>
### func \(\*PairDatabaseError\) Unwrap

```go
func (err *PairDatabaseError) Unwrap() error
```



<a name="PairProtoError"></a>
## type PairProtoError

PairProtoError is included in an events.PairError if the pairing failed due to a protobuf error.

```go
type PairProtoError struct {
    Message  string
    ProtoErr error
}
```

<a name="PairProtoError.Error"></a>
### func \(\*PairProtoError\) Error

```go
func (err *PairProtoError) Error() string
```



<a name="PairProtoError.Unwrap"></a>
### func \(\*PairProtoError\) Unwrap

```go
func (err *PairProtoError) Unwrap() error
```



<a name="ParticipantChange"></a>
## type ParticipantChange



```go
type ParticipantChange string
```

<a name="ParticipantChangeAdd"></a>

```go
const (
    ParticipantChangeAdd     ParticipantChange = "add"
    ParticipantChangeRemove  ParticipantChange = "remove"
    ParticipantChangePromote ParticipantChange = "promote"
    ParticipantChangeDemote  ParticipantChange = "demote"
)
```

<a name="ParticipantRequestChange"></a>
## type ParticipantRequestChange



```go
type ParticipantRequestChange string
```

<a name="ParticipantChangeApprove"></a>

```go
const (
    ParticipantChangeApprove ParticipantRequestChange = "approve"
    ParticipantChangeReject  ParticipantRequestChange = "reject"
)
```

<a name="Proxy"></a>
## type Proxy



```go
type Proxy = func(*http.Request) (*url.URL, error)
```

<a name="PushConfig"></a>
## type PushConfig



```go
type PushConfig interface {
    GetPushConfigAttrs() waBinary.Attrs
}
```

<a name="QRChannelItem"></a>
## type QRChannelItem



```go
type QRChannelItem struct {
    // The type of event, "code" for new QR codes (see Code field) and "error" for pairing errors (see Error) field.
    // For non-code/error events, you can just compare the whole item to the event variables (like QRChannelSuccess).
    Event string
    // If the item is a pair error, then this field contains the error message.
    Error error
    // If the item is a new code, then this field contains the raw data.
    Code string
    // The timeout after which the next code will be sent down the channel.
    Timeout time.Duration
}
```

<a name="RecentMessage"></a>
## type RecentMessage



```go
type RecentMessage struct {
    // contains filtered or unexported fields
}
```

<a name="RecentMessage.IsEmpty"></a>
### func \(RecentMessage\) IsEmpty

```go
func (rm RecentMessage) IsEmpty() bool
```



<a name="ReqCreateGroup"></a>
## type ReqCreateGroup

ReqCreateGroup contains the request data for CreateGroup.

```go
type ReqCreateGroup struct {
    // Group names are limited to 25 characters. A longer group name will cause a 406 not acceptable error.
    Name string
    // You don't need to include your own JID in the participants array, the WhatsApp servers will add it implicitly.
    Participants []types.JID
    // A create key can be provided to deduplicate the group create notification that will be triggered
    // when the group is created. If provided, the JoinedGroup event will contain the same key.
    CreateKey types.MessageID

    types.GroupEphemeral
    types.GroupAnnounce
    types.GroupLocked
    types.GroupMembershipApprovalMode
    // Set IsParent to true to create a community instead of a normal group.
    // When creating a community, the linked announcement group will be created automatically by the server.
    types.GroupParent
    // Set LinkedParentJID to create a group inside a community.
    types.GroupLinkedParent
}
```

<a name="SendRequestExtra"></a>
## type SendRequestExtra

SendRequestExtra contains the optional parameters for SendMessage.

By default, optional parameters don't have to be provided at all, e.g.

```
cli.SendMessage(ctx, to, message)
```

When providing optional parameters, add a single instance of this struct as the last parameter:

```
cli.SendMessage(ctx, to, message, whatsmeow.SendRequestExtra{...})
```

Trying to add multiple extra parameters will return an error.

```go
type SendRequestExtra struct {
    // The message ID to use when sending. If this is not provided, a random message ID will be generated
    ID  types.MessageID
    // JID of the bot to be invoked (optional)
    InlineBotJID types.JID
    // Should the message be sent as a peer message (protocol messages to your own devices, e.g. app state key requests)
    Peer bool
    // A timeout for the send request. Unlike timeouts using the context parameter, this only applies
    // to the actual response waiting and not preparing/encrypting the message.
    // Defaults to 75 seconds. The timeout can be disabled by using a negative value.
    Timeout time.Duration
    // When sending media to newsletters, the Handle field returned by the file upload.
    MediaHandle string

    Meta *types.MsgMetaInfo
    // use this only if you know what you are doing
    AdditionalNodes *[]waBinary.Node
}
```

<a name="SendResponse"></a>
## type SendResponse



```go
type SendResponse struct {
    // The message timestamp returned by the server
    Timestamp time.Time

    // The ID of the sent message
    ID  types.MessageID

    // The server-specified ID of the sent message. Only present for newsletter messages.
    ServerID types.MessageServerID

    // Message handling duration, used for debugging
    DebugTimings MessageDebugTimings

    // The identity the message was sent with (LID or PN)
    // This is currently not reliable in all cases.
    Sender types.JID
}
```

<a name="SetProxyOptions"></a>
## type SetProxyOptions



```go
type SetProxyOptions struct {
    // If NoWebsocket is true, the proxy won't be used for the websocket
    NoWebsocket bool
    // If OnlyLogin is true, the proxy will be used for the pre-login websocket, but not the post-login one
    OnlyLogin bool
    // If NoMedia is true, the proxy won't be used for media uploads/downloads
    NoMedia bool
}
```

<a name="UploadResponse"></a>
## type UploadResponse

UploadResponse contains the data from the attachment upload, which can be put into a message to send the attachment.

```go
type UploadResponse struct {
    URL        string `json:"url"`
    DirectPath string `json:"direct_path"`
    Handle     string `json:"handle"`
    ObjectID   string `json:"object_id"`

    MediaKey      []byte `json:"-"`
    FileEncSHA256 []byte `json:"-"`
    FileSHA256    []byte `json:"-"`
    FileLength    uint64 `json:"-"`
}
```

<a name="UsyncQueryExtras"></a>
## type UsyncQueryExtras



```go
type UsyncQueryExtras struct {
    BotListInfo []types.BotListInfo
}
```

<a name="WebPushConfig"></a>
## type WebPushConfig



```go
type WebPushConfig struct {
    Endpoint string `json:"endpoint"`
    Auth     []byte `json:"auth"`
    P256DH   []byte `json:"p256dh"`
}
```

<a name="WebPushConfig.GetPushConfigAttrs"></a>
### func \(\*WebPushConfig\) GetPushConfigAttrs

```go
func (wpc *WebPushConfig) GetPushConfigAttrs() waBinary.Attrs
```



# sqlstore

```go
import "go.mau.fi/whatsmeow/store/sqlstore"
```

Package sqlstore contains an SQL\-backed implementation of the interfaces in the store package.

Package sqlstore contains an SQL\-backed implementation of the interfaces in the store package.

## Index

- [Variables](<#variables>)
- [type CachedLIDMap](<#CachedLIDMap>)
  - [func NewCachedLIDMap\(db \*dbutil.Database\) \*CachedLIDMap](<#NewCachedLIDMap>)
  - [func \(s \*CachedLIDMap\) FillCache\(ctx context.Context\) error](<#CachedLIDMap.FillCache>)
  - [func \(s \*CachedLIDMap\) GetLIDForPN\(ctx context.Context, pn types.JID\) \(types.JID, error\)](<#CachedLIDMap.GetLIDForPN>)
  - [func \(s \*CachedLIDMap\) GetManyLIDsForPNs\(ctx context.Context, pns \[\]types.JID\) \(map\[types.JID\]types.JID, error\)](<#CachedLIDMap.GetManyLIDsForPNs>)
  - [func \(s \*CachedLIDMap\) GetPNForLID\(ctx context.Context, lid types.JID\) \(types.JID, error\)](<#CachedLIDMap.GetPNForLID>)
  - [func \(s \*CachedLIDMap\) PutLIDMapping\(ctx context.Context, lid, pn types.JID\) error](<#CachedLIDMap.PutLIDMapping>)
  - [func \(s \*CachedLIDMap\) PutManyLIDMappings\(ctx context.Context, mappings \[\]store.LIDMapping\) error](<#CachedLIDMap.PutManyLIDMappings>)
- [type Container](<#Container>)
  - [func New\(ctx context.Context, dialect, address string, log waLog.Logger\) \(\*Container, error\)](<#New>)
  - [func NewWithDB\(db \*sql.DB, dialect string, log waLog.Logger\) \*Container](<#NewWithDB>)
  - [func NewWithWrappedDB\(wrapped \*dbutil.Database, log waLog.Logger\) \*Container](<#NewWithWrappedDB>)
  - [func \(c \*Container\) Close\(\) error](<#Container.Close>)
  - [func \(c \*Container\) DeleteDevice\(ctx context.Context, store \*store.Device\) error](<#Container.DeleteDevice>)
  - [func \(c \*Container\) GetAllDevices\(ctx context.Context\) \(\[\]\*store.Device, error\)](<#Container.GetAllDevices>)
  - [func \(c \*Container\) GetDevice\(ctx context.Context, jid types.JID\) \(\*store.Device, error\)](<#Container.GetDevice>)
  - [func \(c \*Container\) GetFirstDevice\(ctx context.Context\) \(\*store.Device, error\)](<#Container.GetFirstDevice>)
  - [func \(c \*Container\) NewDevice\(\) \*store.Device](<#Container.NewDevice>)
  - [func \(c \*Container\) PutDevice\(ctx context.Context, device \*store.Device\) error](<#Container.PutDevice>)
  - [func \(c \*Container\) Upgrade\(ctx context.Context\) error](<#Container.Upgrade>)
- [type SQLStore](<#SQLStore>)
  - [func NewSQLStore\(c \*Container, jid types.JID\) \*SQLStore](<#NewSQLStore>)
  - [func \(s \*SQLStore\) ClearBufferedEventPlaintext\(ctx context.Context, ciphertextHash \[32\]byte\) error](<#SQLStore.ClearBufferedEventPlaintext>)
  - [func \(s \*SQLStore\) DeleteAllIdentities\(ctx context.Context, phone string\) error](<#SQLStore.DeleteAllIdentities>)
  - [func \(s \*SQLStore\) DeleteAllSessions\(ctx context.Context, phone string\) error](<#SQLStore.DeleteAllSessions>)
  - [func \(s \*SQLStore\) DeleteAppStateMutationMACs\(ctx context.Context, name string, indexMACs \[\]\[\]byte\) \(err error\)](<#SQLStore.DeleteAppStateMutationMACs>)
  - [func \(s \*SQLStore\) DeleteAppStateVersion\(ctx context.Context, name string\) error](<#SQLStore.DeleteAppStateVersion>)
  - [func \(s \*SQLStore\) DeleteIdentity\(ctx context.Context, address string\) error](<#SQLStore.DeleteIdentity>)
  - [func \(s \*SQLStore\) DeleteOldBufferedHashes\(ctx context.Context\) error](<#SQLStore.DeleteOldBufferedHashes>)
  - [func \(s \*SQLStore\) DeleteSession\(ctx context.Context, address string\) error](<#SQLStore.DeleteSession>)
  - [func \(s \*SQLStore\) DoDecryptionTxn\(ctx context.Context, fn func\(context.Context\) error\) error](<#SQLStore.DoDecryptionTxn>)
  - [func \(s \*SQLStore\) GenOnePreKey\(ctx context.Context\) \(\*keys.PreKey, error\)](<#SQLStore.GenOnePreKey>)
  - [func \(s \*SQLStore\) GetAllContacts\(ctx context.Context\) \(map\[types.JID\]types.ContactInfo, error\)](<#SQLStore.GetAllContacts>)
  - [func \(s \*SQLStore\) GetAppStateMutationMAC\(ctx context.Context, name string, indexMAC \[\]byte\) \(valueMAC \[\]byte, err error\)](<#SQLStore.GetAppStateMutationMAC>)
  - [func \(s \*SQLStore\) GetAppStateSyncKey\(ctx context.Context, id \[\]byte\) \(\*store.AppStateSyncKey, error\)](<#SQLStore.GetAppStateSyncKey>)
  - [func \(s \*SQLStore\) GetAppStateVersion\(ctx context.Context, name string\) \(version uint64, hash \[128\]byte, err error\)](<#SQLStore.GetAppStateVersion>)
  - [func \(s \*SQLStore\) GetBufferedEvent\(ctx context.Context, ciphertextHash \[32\]byte\) \(\*store.BufferedEvent, error\)](<#SQLStore.GetBufferedEvent>)
  - [func \(s \*SQLStore\) GetChatSettings\(ctx context.Context, chat types.JID\) \(settings types.LocalChatSettings, err error\)](<#SQLStore.GetChatSettings>)
  - [func \(s \*SQLStore\) GetContact\(ctx context.Context, user types.JID\) \(types.ContactInfo, error\)](<#SQLStore.GetContact>)
  - [func \(s \*SQLStore\) GetLatestAppStateSyncKeyID\(ctx context.Context\) \(\[\]byte, error\)](<#SQLStore.GetLatestAppStateSyncKeyID>)
  - [func \(s \*SQLStore\) GetManySessions\(ctx context.Context, addresses \[\]string\) \(map\[string\]\[\]byte, error\)](<#SQLStore.GetManySessions>)
  - [func \(s \*SQLStore\) GetMessageSecret\(ctx context.Context, chat, sender types.JID, id types.MessageID\) \(secret \[\]byte, realSender types.JID, err error\)](<#SQLStore.GetMessageSecret>)
  - [func \(s \*SQLStore\) GetOrGenPreKeys\(ctx context.Context, count uint32\) \(\[\]\*keys.PreKey, error\)](<#SQLStore.GetOrGenPreKeys>)
  - [func \(s \*SQLStore\) GetPreKey\(ctx context.Context, id uint32\) \(\*keys.PreKey, error\)](<#SQLStore.GetPreKey>)
  - [func \(s \*SQLStore\) GetPrivacyToken\(ctx context.Context, user types.JID\) \(\*store.PrivacyToken, error\)](<#SQLStore.GetPrivacyToken>)
  - [func \(s \*SQLStore\) GetSenderKey\(ctx context.Context, group, user string\) \(key \[\]byte, err error\)](<#SQLStore.GetSenderKey>)
  - [func \(s \*SQLStore\) GetSession\(ctx context.Context, address string\) \(session \[\]byte, err error\)](<#SQLStore.GetSession>)
  - [func \(s \*SQLStore\) HasSession\(ctx context.Context, address string\) \(has bool, err error\)](<#SQLStore.HasSession>)
  - [func \(s \*SQLStore\) IsTrustedIdentity\(ctx context.Context, address string, key \[32\]byte\) \(bool, error\)](<#SQLStore.IsTrustedIdentity>)
  - [func \(s \*SQLStore\) MarkPreKeysAsUploaded\(ctx context.Context, upToID uint32\) error](<#SQLStore.MarkPreKeysAsUploaded>)
  - [func \(s \*SQLStore\) MigratePNToLID\(ctx context.Context, pn, lid types.JID\) error](<#SQLStore.MigratePNToLID>)
  - [func \(s \*SQLStore\) PutAllContactNames\(ctx context.Context, contacts \[\]store.ContactEntry\) error](<#SQLStore.PutAllContactNames>)
  - [func \(s \*SQLStore\) PutAppStateMutationMACs\(ctx context.Context, name string, version uint64, mutations \[\]store.AppStateMutationMAC\) error](<#SQLStore.PutAppStateMutationMACs>)
  - [func \(s \*SQLStore\) PutAppStateSyncKey\(ctx context.Context, id \[\]byte, key store.AppStateSyncKey\) error](<#SQLStore.PutAppStateSyncKey>)
  - [func \(s \*SQLStore\) PutAppStateVersion\(ctx context.Context, name string, version uint64, hash \[128\]byte\) error](<#SQLStore.PutAppStateVersion>)
  - [func \(s \*SQLStore\) PutArchived\(ctx context.Context, chat types.JID, archived bool\) error](<#SQLStore.PutArchived>)
  - [func \(s \*SQLStore\) PutBufferedEvent\(ctx context.Context, ciphertextHash \[32\]byte, plaintext \[\]byte, serverTimestamp time.Time\) error](<#SQLStore.PutBufferedEvent>)
  - [func \(s \*SQLStore\) PutBusinessName\(ctx context.Context, user types.JID, businessName string\) \(bool, string, error\)](<#SQLStore.PutBusinessName>)
  - [func \(s \*SQLStore\) PutContactName\(ctx context.Context, user types.JID, firstName, fullName string\) error](<#SQLStore.PutContactName>)
  - [func \(s \*SQLStore\) PutIdentity\(ctx context.Context, address string, key \[32\]byte\) error](<#SQLStore.PutIdentity>)
  - [func \(s \*SQLStore\) PutManyRedactedPhones\(ctx context.Context, entries \[\]store.RedactedPhoneEntry\) error](<#SQLStore.PutManyRedactedPhones>)
  - [func \(s \*SQLStore\) PutManySessions\(ctx context.Context, sessions map\[string\]\[\]byte\) error](<#SQLStore.PutManySessions>)
  - [func \(s \*SQLStore\) PutMessageSecret\(ctx context.Context, chat, sender types.JID, id types.MessageID, secret \[\]byte\) \(err error\)](<#SQLStore.PutMessageSecret>)
  - [func \(s \*SQLStore\) PutMessageSecrets\(ctx context.Context, inserts \[\]store.MessageSecretInsert\) \(err error\)](<#SQLStore.PutMessageSecrets>)
  - [func \(s \*SQLStore\) PutMutedUntil\(ctx context.Context, chat types.JID, mutedUntil time.Time\) error](<#SQLStore.PutMutedUntil>)
  - [func \(s \*SQLStore\) PutPinned\(ctx context.Context, chat types.JID, pinned bool\) error](<#SQLStore.PutPinned>)
  - [func \(s \*SQLStore\) PutPrivacyTokens\(ctx context.Context, tokens ...store.PrivacyToken\) error](<#SQLStore.PutPrivacyTokens>)
  - [func \(s \*SQLStore\) PutPushName\(ctx context.Context, user types.JID, pushName string\) \(bool, string, error\)](<#SQLStore.PutPushName>)
  - [func \(s \*SQLStore\) PutSenderKey\(ctx context.Context, group, user string, session \[\]byte\) error](<#SQLStore.PutSenderKey>)
  - [func \(s \*SQLStore\) PutSession\(ctx context.Context, address string, session \[\]byte\) error](<#SQLStore.PutSession>)
  - [func \(s \*SQLStore\) RemovePreKey\(ctx context.Context, id uint32\) error](<#SQLStore.RemovePreKey>)
  - [func \(s \*SQLStore\) UploadedPreKeyCount\(ctx context.Context\) \(count int, err error\)](<#SQLStore.UploadedPreKeyCount>)


## Variables

<a name="ErrDeviceIDMustBeSet"></a>ErrDeviceIDMustBeSet is the error returned by PutDevice if you try to save a device before knowing its JID.

```go
var ErrDeviceIDMustBeSet = errors.New("device JID must be known before accessing database")
```

<a name="ErrInvalidLength"></a>ErrInvalidLength is returned by some database getters if the database returned a byte array with an unexpected length. This should be impossible, as the database schema contains CHECK\(\)s for all the relevant columns.

```go
var ErrInvalidLength = errors.New("database returned byte array with illegal length")
```

<a name="PostgresArrayWrapper"></a>PostgresArrayWrapper is a function to wrap array values before passing them to the sql package.

When using github.com/lib/pq, you should set

```
whatsmeow.PostgresArrayWrapper = pq.Array
```

```go
var PostgresArrayWrapper func(any) interface {
    driver.Valuer
    sql.Scanner
}
```

<a name="CachedLIDMap"></a>
## type CachedLIDMap



```go
type CachedLIDMap struct {
    // contains filtered or unexported fields
}
```

<a name="NewCachedLIDMap"></a>
### func NewCachedLIDMap

```go
func NewCachedLIDMap(db *dbutil.Database) *CachedLIDMap
```



<a name="CachedLIDMap.FillCache"></a>
### func \(\*CachedLIDMap\) FillCache

```go
func (s *CachedLIDMap) FillCache(ctx context.Context) error
```



<a name="CachedLIDMap.GetLIDForPN"></a>
### func \(\*CachedLIDMap\) GetLIDForPN

```go
func (s *CachedLIDMap) GetLIDForPN(ctx context.Context, pn types.JID) (types.JID, error)
```



<a name="CachedLIDMap.GetManyLIDsForPNs"></a>
### func \(\*CachedLIDMap\) GetManyLIDsForPNs

```go
func (s *CachedLIDMap) GetManyLIDsForPNs(ctx context.Context, pns []types.JID) (map[types.JID]types.JID, error)
```



<a name="CachedLIDMap.GetPNForLID"></a>
### func \(\*CachedLIDMap\) GetPNForLID

```go
func (s *CachedLIDMap) GetPNForLID(ctx context.Context, lid types.JID) (types.JID, error)
```



<a name="CachedLIDMap.PutLIDMapping"></a>
### func \(\*CachedLIDMap\) PutLIDMapping

```go
func (s *CachedLIDMap) PutLIDMapping(ctx context.Context, lid, pn types.JID) error
```



<a name="CachedLIDMap.PutManyLIDMappings"></a>
### func \(\*CachedLIDMap\) PutManyLIDMappings

```go
func (s *CachedLIDMap) PutManyLIDMappings(ctx context.Context, mappings []store.LIDMapping) error
```



<a name="Container"></a>
## type Container

Container is a wrapper for a SQL database that can contain multiple whatsmeow sessions.

```go
type Container struct {
    LIDMap *CachedLIDMap
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func New

```go
func New(ctx context.Context, dialect, address string, log waLog.Logger) (*Container, error)
```

New connects to the given SQL database and wraps it in a Container.

Only SQLite and Postgres are currently fully supported.

The logger can be nil and will default to a no\-op logger.

When using SQLite, it's strongly recommended to enable foreign keys by adding \`?\_foreign\_keys=true\`:

```
container, err := sqlstore.New(context.Background(), "sqlite3", "file:yoursqlitefile.db?_foreign_keys=on", nil)
```

<a name="NewWithDB"></a>
### func NewWithDB

```go
func NewWithDB(db *sql.DB, dialect string, log waLog.Logger) *Container
```

NewWithDB wraps an existing SQL connection in a Container.

Only SQLite and Postgres are currently fully supported.

The logger can be nil and will default to a no\-op logger.

When using SQLite, it's strongly recommended to enable foreign keys by adding \`?\_foreign\_keys=true\`:

```
db, err := sql.Open("sqlite3", "file:yoursqlitefile.db?_foreign_keys=on")
if err != nil {
    panic(err)
}
container := sqlstore.NewWithDB(db, "sqlite3", nil)
```

This method does not call Upgrade automatically like New does, so you must call it yourself:

```
container := sqlstore.NewWithDB(...)
err := container.Upgrade()
```

<a name="NewWithWrappedDB"></a>
### func NewWithWrappedDB

```go
func NewWithWrappedDB(wrapped *dbutil.Database, log waLog.Logger) *Container
```



<a name="Container.Close"></a>
### func \(\*Container\) Close

```go
func (c *Container) Close() error
```

Close will close the container's database

<a name="Container.DeleteDevice"></a>
### func \(\*Container\) DeleteDevice

```go
func (c *Container) DeleteDevice(ctx context.Context, store *store.Device) error
```

DeleteDevice deletes the given device from this database. This should be called through Device.Delete\(\)

<a name="Container.GetAllDevices"></a>
### func \(\*Container\) GetAllDevices

```go
func (c *Container) GetAllDevices(ctx context.Context) ([]*store.Device, error)
```

GetAllDevices finds all the devices in the database.

<a name="Container.GetDevice"></a>
### func \(\*Container\) GetDevice

```go
func (c *Container) GetDevice(ctx context.Context, jid types.JID) (*store.Device, error)
```

GetDevice finds the device with the specified JID in the database.

If the device is not found, nil is returned instead.

Note that the parameter usually must be an AD\-JID.

<a name="Container.GetFirstDevice"></a>
### func \(\*Container\) GetFirstDevice

```go
func (c *Container) GetFirstDevice(ctx context.Context) (*store.Device, error)
```

GetFirstDevice is a convenience method for getting the first device in the store. If there are no devices, then a new device will be created. You should only use this if you don't want to have multiple sessions simultaneously.

<a name="Container.NewDevice"></a>
### func \(\*Container\) NewDevice

```go
func (c *Container) NewDevice() *store.Device
```

NewDevice creates a new device in this database.

No data is actually stored before Save is called. However, the pairing process will automatically call Save after a successful pairing, so you most likely don't need to call it yourself.

<a name="Container.PutDevice"></a>
### func \(\*Container\) PutDevice

```go
func (c *Container) PutDevice(ctx context.Context, device *store.Device) error
```

PutDevice stores the given device in this database. This should be called through Device.Save\(\) \(which usually doesn't need to be called manually, as the library does that automatically when relevant\).

<a name="Container.Upgrade"></a>
### func \(\*Container\) Upgrade

```go
func (c *Container) Upgrade(ctx context.Context) error
```

Upgrade upgrades the database from the current to the latest version available.

<a name="SQLStore"></a>
## type SQLStore



```go
type SQLStore struct {
    *Container
    JID string
    // contains filtered or unexported fields
}
```

<a name="NewSQLStore"></a>
### func NewSQLStore

```go
func NewSQLStore(c *Container, jid types.JID) *SQLStore
```

NewSQLStore creates a new SQLStore with the given database container and user JID. It contains implementations of all the different stores in the store package.

In general, you should use Container.NewDevice or Container.GetDevice instead of this.

<a name="SQLStore.ClearBufferedEventPlaintext"></a>
### func \(\*SQLStore\) ClearBufferedEventPlaintext

```go
func (s *SQLStore) ClearBufferedEventPlaintext(ctx context.Context, ciphertextHash [32]byte) error
```



<a name="SQLStore.DeleteAllIdentities"></a>
### func \(\*SQLStore\) DeleteAllIdentities

```go
func (s *SQLStore) DeleteAllIdentities(ctx context.Context, phone string) error
```



<a name="SQLStore.DeleteAllSessions"></a>
### func \(\*SQLStore\) DeleteAllSessions

```go
func (s *SQLStore) DeleteAllSessions(ctx context.Context, phone string) error
```



<a name="SQLStore.DeleteAppStateMutationMACs"></a>
### func \(\*SQLStore\) DeleteAppStateMutationMACs

```go
func (s *SQLStore) DeleteAppStateMutationMACs(ctx context.Context, name string, indexMACs [][]byte) (err error)
```



<a name="SQLStore.DeleteAppStateVersion"></a>
### func \(\*SQLStore\) DeleteAppStateVersion

```go
func (s *SQLStore) DeleteAppStateVersion(ctx context.Context, name string) error
```



<a name="SQLStore.DeleteIdentity"></a>
### func \(\*SQLStore\) DeleteIdentity

```go
func (s *SQLStore) DeleteIdentity(ctx context.Context, address string) error
```



<a name="SQLStore.DeleteOldBufferedHashes"></a>
### func \(\*SQLStore\) DeleteOldBufferedHashes

```go
func (s *SQLStore) DeleteOldBufferedHashes(ctx context.Context) error
```



<a name="SQLStore.DeleteSession"></a>
### func \(\*SQLStore\) DeleteSession

```go
func (s *SQLStore) DeleteSession(ctx context.Context, address string) error
```



<a name="SQLStore.DoDecryptionTxn"></a>
### func \(\*SQLStore\) DoDecryptionTxn

```go
func (s *SQLStore) DoDecryptionTxn(ctx context.Context, fn func(context.Context) error) error
```



<a name="SQLStore.GenOnePreKey"></a>
### func \(\*SQLStore\) GenOnePreKey

```go
func (s *SQLStore) GenOnePreKey(ctx context.Context) (*keys.PreKey, error)
```



<a name="SQLStore.GetAllContacts"></a>
### func \(\*SQLStore\) GetAllContacts

```go
func (s *SQLStore) GetAllContacts(ctx context.Context) (map[types.JID]types.ContactInfo, error)
```



<a name="SQLStore.GetAppStateMutationMAC"></a>
### func \(\*SQLStore\) GetAppStateMutationMAC

```go
func (s *SQLStore) GetAppStateMutationMAC(ctx context.Context, name string, indexMAC []byte) (valueMAC []byte, err error)
```



<a name="SQLStore.GetAppStateSyncKey"></a>
### func \(\*SQLStore\) GetAppStateSyncKey

```go
func (s *SQLStore) GetAppStateSyncKey(ctx context.Context, id []byte) (*store.AppStateSyncKey, error)
```



<a name="SQLStore.GetAppStateVersion"></a>
### func \(\*SQLStore\) GetAppStateVersion

```go
func (s *SQLStore) GetAppStateVersion(ctx context.Context, name string) (version uint64, hash [128]byte, err error)
```



<a name="SQLStore.GetBufferedEvent"></a>
### func \(\*SQLStore\) GetBufferedEvent

```go
func (s *SQLStore) GetBufferedEvent(ctx context.Context, ciphertextHash [32]byte) (*store.BufferedEvent, error)
```



<a name="SQLStore.GetChatSettings"></a>
### func \(\*SQLStore\) GetChatSettings

```go
func (s *SQLStore) GetChatSettings(ctx context.Context, chat types.JID) (settings types.LocalChatSettings, err error)
```



<a name="SQLStore.GetContact"></a>
### func \(\*SQLStore\) GetContact

```go
func (s *SQLStore) GetContact(ctx context.Context, user types.JID) (types.ContactInfo, error)
```



<a name="SQLStore.GetLatestAppStateSyncKeyID"></a>
### func \(\*SQLStore\) GetLatestAppStateSyncKeyID

```go
func (s *SQLStore) GetLatestAppStateSyncKeyID(ctx context.Context) ([]byte, error)
```



<a name="SQLStore.GetManySessions"></a>
### func \(\*SQLStore\) GetManySessions

```go
func (s *SQLStore) GetManySessions(ctx context.Context, addresses []string) (map[string][]byte, error)
```



<a name="SQLStore.GetMessageSecret"></a>
### func \(\*SQLStore\) GetMessageSecret

```go
func (s *SQLStore) GetMessageSecret(ctx context.Context, chat, sender types.JID, id types.MessageID) (secret []byte, realSender types.JID, err error)
```



<a name="SQLStore.GetOrGenPreKeys"></a>
### func \(\*SQLStore\) GetOrGenPreKeys

```go
func (s *SQLStore) GetOrGenPreKeys(ctx context.Context, count uint32) ([]*keys.PreKey, error)
```



<a name="SQLStore.GetPreKey"></a>
### func \(\*SQLStore\) GetPreKey

```go
func (s *SQLStore) GetPreKey(ctx context.Context, id uint32) (*keys.PreKey, error)
```



<a name="SQLStore.GetPrivacyToken"></a>
### func \(\*SQLStore\) GetPrivacyToken

```go
func (s *SQLStore) GetPrivacyToken(ctx context.Context, user types.JID) (*store.PrivacyToken, error)
```



<a name="SQLStore.GetSenderKey"></a>
### func \(\*SQLStore\) GetSenderKey

```go
func (s *SQLStore) GetSenderKey(ctx context.Context, group, user string) (key []byte, err error)
```



<a name="SQLStore.GetSession"></a>
### func \(\*SQLStore\) GetSession

```go
func (s *SQLStore) GetSession(ctx context.Context, address string) (session []byte, err error)
```



<a name="SQLStore.HasSession"></a>
### func \(\*SQLStore\) HasSession

```go
func (s *SQLStore) HasSession(ctx context.Context, address string) (has bool, err error)
```



<a name="SQLStore.IsTrustedIdentity"></a>
### func \(\*SQLStore\) IsTrustedIdentity

```go
func (s *SQLStore) IsTrustedIdentity(ctx context.Context, address string, key [32]byte) (bool, error)
```



<a name="SQLStore.MarkPreKeysAsUploaded"></a>
### func \(\*SQLStore\) MarkPreKeysAsUploaded

```go
func (s *SQLStore) MarkPreKeysAsUploaded(ctx context.Context, upToID uint32) error
```



<a name="SQLStore.MigratePNToLID"></a>
### func \(\*SQLStore\) MigratePNToLID

```go
func (s *SQLStore) MigratePNToLID(ctx context.Context, pn, lid types.JID) error
```



<a name="SQLStore.PutAllContactNames"></a>
### func \(\*SQLStore\) PutAllContactNames

```go
func (s *SQLStore) PutAllContactNames(ctx context.Context, contacts []store.ContactEntry) error
```



<a name="SQLStore.PutAppStateMutationMACs"></a>
### func \(\*SQLStore\) PutAppStateMutationMACs

```go
func (s *SQLStore) PutAppStateMutationMACs(ctx context.Context, name string, version uint64, mutations []store.AppStateMutationMAC) error
```



<a name="SQLStore.PutAppStateSyncKey"></a>
### func \(\*SQLStore\) PutAppStateSyncKey

```go
func (s *SQLStore) PutAppStateSyncKey(ctx context.Context, id []byte, key store.AppStateSyncKey) error
```



<a name="SQLStore.PutAppStateVersion"></a>
### func \(\*SQLStore\) PutAppStateVersion

```go
func (s *SQLStore) PutAppStateVersion(ctx context.Context, name string, version uint64, hash [128]byte) error
```



<a name="SQLStore.PutArchived"></a>
### func \(\*SQLStore\) PutArchived

```go
func (s *SQLStore) PutArchived(ctx context.Context, chat types.JID, archived bool) error
```



<a name="SQLStore.PutBufferedEvent"></a>
### func \(\*SQLStore\) PutBufferedEvent

```go
func (s *SQLStore) PutBufferedEvent(ctx context.Context, ciphertextHash [32]byte, plaintext []byte, serverTimestamp time.Time) error
```



<a name="SQLStore.PutBusinessName"></a>
### func \(\*SQLStore\) PutBusinessName

```go
func (s *SQLStore) PutBusinessName(ctx context.Context, user types.JID, businessName string) (bool, string, error)
```



<a name="SQLStore.PutContactName"></a>
### func \(\*SQLStore\) PutContactName

```go
func (s *SQLStore) PutContactName(ctx context.Context, user types.JID, firstName, fullName string) error
```



<a name="SQLStore.PutIdentity"></a>
### func \(\*SQLStore\) PutIdentity

```go
func (s *SQLStore) PutIdentity(ctx context.Context, address string, key [32]byte) error
```



<a name="SQLStore.PutManyRedactedPhones"></a>
### func \(\*SQLStore\) PutManyRedactedPhones

```go
func (s *SQLStore) PutManyRedactedPhones(ctx context.Context, entries []store.RedactedPhoneEntry) error
```



<a name="SQLStore.PutManySessions"></a>
### func \(\*SQLStore\) PutManySessions

```go
func (s *SQLStore) PutManySessions(ctx context.Context, sessions map[string][]byte) error
```



<a name="SQLStore.PutMessageSecret"></a>
### func \(\*SQLStore\) PutMessageSecret

```go
func (s *SQLStore) PutMessageSecret(ctx context.Context, chat, sender types.JID, id types.MessageID, secret []byte) (err error)
```



<a name="SQLStore.PutMessageSecrets"></a>
### func \(\*SQLStore\) PutMessageSecrets

```go
func (s *SQLStore) PutMessageSecrets(ctx context.Context, inserts []store.MessageSecretInsert) (err error)
```



<a name="SQLStore.PutMutedUntil"></a>
### func \(\*SQLStore\) PutMutedUntil

```go
func (s *SQLStore) PutMutedUntil(ctx context.Context, chat types.JID, mutedUntil time.Time) error
```



<a name="SQLStore.PutPinned"></a>
### func \(\*SQLStore\) PutPinned

```go
func (s *SQLStore) PutPinned(ctx context.Context, chat types.JID, pinned bool) error
```



<a name="SQLStore.PutPrivacyTokens"></a>
### func \(\*SQLStore\) PutPrivacyTokens

```go
func (s *SQLStore) PutPrivacyTokens(ctx context.Context, tokens ...store.PrivacyToken) error
```



<a name="SQLStore.PutPushName"></a>
### func \(\*SQLStore\) PutPushName

```go
func (s *SQLStore) PutPushName(ctx context.Context, user types.JID, pushName string) (bool, string, error)
```



<a name="SQLStore.PutSenderKey"></a>
### func \(\*SQLStore\) PutSenderKey

```go
func (s *SQLStore) PutSenderKey(ctx context.Context, group, user string, session []byte) error
```



<a name="SQLStore.PutSession"></a>
### func \(\*SQLStore\) PutSession

```go
func (s *SQLStore) PutSession(ctx context.Context, address string, session []byte) error
```



<a name="SQLStore.RemovePreKey"></a>
### func \(\*SQLStore\) RemovePreKey

```go
func (s *SQLStore) RemovePreKey(ctx context.Context, id uint32) error
```



<a name="SQLStore.UploadedPreKeyCount"></a>
### func \(\*SQLStore\) UploadedPreKeyCount

```go
func (s *SQLStore) UploadedPreKeyCount(ctx context.Context) (count int, err error)
```



# events

```go
import "go.mau.fi/whatsmeow/types/events"
```

Package events contains all the events that whatsmeow.Client emits to functions registered with AddEventHandler.

## Index

- [Constants](<#constants>)
- [type AppState](<#AppState>)
- [type AppStateSyncComplete](<#AppStateSyncComplete>)
- [type Archive](<#Archive>)
- [type Blocklist](<#Blocklist>)
- [type BlocklistAction](<#BlocklistAction>)
- [type BlocklistChange](<#BlocklistChange>)
- [type BlocklistChangeAction](<#BlocklistChangeAction>)
- [type BusinessName](<#BusinessName>)
- [type CATRefreshError](<#CATRefreshError>)
  - [func \(\*CATRefreshError\) PermanentDisconnectDescription\(\) string](<#CATRefreshError.PermanentDisconnectDescription>)
- [type CallAccept](<#CallAccept>)
- [type CallOffer](<#CallOffer>)
- [type CallOfferNotice](<#CallOfferNotice>)
- [type CallPreAccept](<#CallPreAccept>)
- [type CallReject](<#CallReject>)
- [type CallRelayLatency](<#CallRelayLatency>)
- [type CallTerminate](<#CallTerminate>)
- [type CallTransport](<#CallTransport>)
- [type ChatPresence](<#ChatPresence>)
- [type ClearChat](<#ClearChat>)
- [type ClientOutdated](<#ClientOutdated>)
  - [func \(\*ClientOutdated\) PermanentDisconnectDescription\(\) string](<#ClientOutdated.PermanentDisconnectDescription>)
- [type ConnectFailure](<#ConnectFailure>)
  - [func \(cf \*ConnectFailure\) PermanentDisconnectDescription\(\) string](<#ConnectFailure.PermanentDisconnectDescription>)
- [type ConnectFailureReason](<#ConnectFailureReason>)
  - [func \(cfr ConnectFailureReason\) IsLoggedOut\(\) bool](<#ConnectFailureReason.IsLoggedOut>)
  - [func \(cfr ConnectFailureReason\) NumberString\(\) string](<#ConnectFailureReason.NumberString>)
  - [func \(cfr ConnectFailureReason\) String\(\) string](<#ConnectFailureReason.String>)
- [type Connected](<#Connected>)
- [type Contact](<#Contact>)
- [type DecryptFailMode](<#DecryptFailMode>)
- [type DeleteChat](<#DeleteChat>)
- [type DeleteForMe](<#DeleteForMe>)
- [type Disconnected](<#Disconnected>)
- [type FBMessage](<#FBMessage>)
  - [func \(evt \*FBMessage\) GetArmadillo\(\) \*waArmadilloApplication.Armadillo](<#FBMessage.GetArmadillo>)
  - [func \(evt \*FBMessage\) GetConsumerApplication\(\) \*waConsumerApplication.ConsumerApplication](<#FBMessage.GetConsumerApplication>)
- [type GroupInfo](<#GroupInfo>)
- [type HistorySync](<#HistorySync>)
- [type IdentityChange](<#IdentityChange>)
- [type JoinedGroup](<#JoinedGroup>)
- [type KeepAliveRestored](<#KeepAliveRestored>)
- [type KeepAliveTimeout](<#KeepAliveTimeout>)
- [type LabelAssociationChat](<#LabelAssociationChat>)
- [type LabelAssociationMessage](<#LabelAssociationMessage>)
- [type LabelEdit](<#LabelEdit>)
- [type LoggedOut](<#LoggedOut>)
  - [func \(l \*LoggedOut\) PermanentDisconnectDescription\(\) string](<#LoggedOut.PermanentDisconnectDescription>)
- [type ManualLoginReconnect](<#ManualLoginReconnect>)
- [type MarkChatAsRead](<#MarkChatAsRead>)
- [type MediaRetry](<#MediaRetry>)
- [type MediaRetryError](<#MediaRetryError>)
- [type Message](<#Message>)
  - [func \(evt \*Message\) UnwrapRaw\(\) \*Message](<#Message.UnwrapRaw>)
- [type Mute](<#Mute>)
- [type NewsletterJoin](<#NewsletterJoin>)
- [type NewsletterLeave](<#NewsletterLeave>)
- [type NewsletterLiveUpdate](<#NewsletterLiveUpdate>)
- [type NewsletterMessageMeta](<#NewsletterMessageMeta>)
- [type NewsletterMuteChange](<#NewsletterMuteChange>)
- [type OfflineSyncCompleted](<#OfflineSyncCompleted>)
- [type OfflineSyncPreview](<#OfflineSyncPreview>)
- [type PairError](<#PairError>)
- [type PairSuccess](<#PairSuccess>)
- [type PermanentDisconnect](<#PermanentDisconnect>)
- [type Picture](<#Picture>)
- [type Pin](<#Pin>)
- [type Presence](<#Presence>)
- [type PrivacySettings](<#PrivacySettings>)
- [type PushName](<#PushName>)
- [type PushNameSetting](<#PushNameSetting>)
- [type QR](<#QR>)
- [type QRScannedWithoutMultidevice](<#QRScannedWithoutMultidevice>)
- [type Receipt](<#Receipt>)
- [type ReceiptType](<#ReceiptType>)
- [type Star](<#Star>)
- [type StreamError](<#StreamError>)
- [type StreamReplaced](<#StreamReplaced>)
  - [func \(\*StreamReplaced\) PermanentDisconnectDescription\(\) string](<#StreamReplaced.PermanentDisconnectDescription>)
- [type TempBanReason](<#TempBanReason>)
  - [func \(tbr TempBanReason\) String\(\) string](<#TempBanReason.String>)
- [type TemporaryBan](<#TemporaryBan>)
  - [func \(tb \*TemporaryBan\) PermanentDisconnectDescription\(\) string](<#TemporaryBan.PermanentDisconnectDescription>)
  - [func \(tb \*TemporaryBan\) String\(\) string](<#TemporaryBan.String>)
- [type UnarchiveChatsSetting](<#UnarchiveChatsSetting>)
- [type UnavailableType](<#UnavailableType>)
- [type UndecryptableMessage](<#UndecryptableMessage>)
- [type UnknownCallEvent](<#UnknownCallEvent>)
- [type UserAbout](<#UserAbout>)
- [type UserStatusMute](<#UserStatusMute>)


## Constants

<a name="ReceiptTypeDelivered"></a>Deprecated: use types.ReceiptType\* constants directly

```go
const (
    ReceiptTypeDelivered = types.ReceiptTypeDelivered
    ReceiptTypeSender    = types.ReceiptTypeSender
    ReceiptTypeRetry     = types.ReceiptTypeRetry
    ReceiptTypeRead      = types.ReceiptTypeRead
    ReceiptTypeReadSelf  = types.ReceiptTypeReadSelf
    ReceiptTypePlayed    = types.ReceiptTypePlayed
)
```

<a name="AppState"></a>
## type AppState

AppState is emitted directly for new data received from app state syncing. You should generally use the higher\-level events like events.Contact and events.Mute.

```go
type AppState struct {
    Index []string
    *waSyncAction.SyncActionValue
}
```

<a name="AppStateSyncComplete"></a>
## type AppStateSyncComplete

AppStateSyncComplete is emitted when app state is resynced.

```go
type AppStateSyncComplete struct {
    Name appstate.WAPatchName
}
```

<a name="Archive"></a>
## type Archive

Archive is emitted when a chat is archived or unarchived from another device.

```go
type Archive struct {
    JID       types.JID // The chat which was archived or unarchived.
    Timestamp time.Time // The time when the (un)archiving happened.

    Action       *waSyncAction.ArchiveChatAction // The current archival status of the chat.
    FromFullSync bool                            // Whether the action is emitted because of a fullSync
}
```

<a name="Blocklist"></a>
## type Blocklist

Blocklist is emitted when the user's blocked user list is changed.

```go
type Blocklist struct {
    // Action specifies what happened. If it's empty, there should be a list of changes in the Changes list.
    // If it's "modify", then the Changes list will be empty and the whole blocklist should be re-requested.
    Action    BlocklistAction
    DHash     string
    PrevDHash string
    Changes   []BlocklistChange
}
```

<a name="BlocklistAction"></a>
## type BlocklistAction



```go
type BlocklistAction string
```

<a name="BlocklistActionDefault"></a>

```go
const (
    BlocklistActionDefault BlocklistAction = ""
    BlocklistActionModify  BlocklistAction = "modify"
)
```

<a name="BlocklistChange"></a>
## type BlocklistChange



```go
type BlocklistChange struct {
    JID    types.JID
    Action BlocklistChangeAction
}
```

<a name="BlocklistChangeAction"></a>
## type BlocklistChangeAction



```go
type BlocklistChangeAction string
```

<a name="BlocklistChangeActionBlock"></a>

```go
const (
    BlocklistChangeActionBlock   BlocklistChangeAction = "block"
    BlocklistChangeActionUnblock BlocklistChangeAction = "unblock"
)
```

<a name="BusinessName"></a>
## type BusinessName

BusinessName is emitted when a message is received with a different verified business name than the previous value cached for the same user.

```go
type BusinessName struct {
    JID             types.JID
    Message         *types.MessageInfo // This is only present if the change was detected in a message.
    OldBusinessName string
    NewBusinessName string
}
```

<a name="CATRefreshError"></a>
## type CATRefreshError



```go
type CATRefreshError struct {
    Error error
}
```

<a name="CATRefreshError.PermanentDisconnectDescription"></a>
### func \(\*CATRefreshError\) PermanentDisconnectDescription

```go
func (*CATRefreshError) PermanentDisconnectDescription() string
```



<a name="CallAccept"></a>
## type CallAccept

CallAccept is emitted when a call is accepted on WhatsApp.

```go
type CallAccept struct {
    types.BasicCallMeta
    types.CallRemoteMeta

    Data *waBinary.Node
}
```

<a name="CallOffer"></a>
## type CallOffer

CallOffer is emitted when the user receives a call on WhatsApp.

```go
type CallOffer struct {
    types.BasicCallMeta
    types.CallRemoteMeta

    Data *waBinary.Node // The call offer data
}
```

<a name="CallOfferNotice"></a>
## type CallOfferNotice

CallOfferNotice is emitted when the user receives a notice of a call on WhatsApp. This seems to be primarily for group calls \(whereas CallOffer is for 1:1 calls\).

```go
type CallOfferNotice struct {
    types.BasicCallMeta

    Media string // "audio" or "video" depending on call type
    Type  string // "group" when it's a group call

    Data *waBinary.Node
}
```

<a name="CallPreAccept"></a>
## type CallPreAccept



```go
type CallPreAccept struct {
    types.BasicCallMeta
    types.CallRemoteMeta

    Data *waBinary.Node
}
```

<a name="CallReject"></a>
## type CallReject

CallReject is sent when the other party rejects the call on WhatsApp.

```go
type CallReject struct {
    types.BasicCallMeta
    Data *waBinary.Node
}
```

<a name="CallRelayLatency"></a>
## type CallRelayLatency

CallRelayLatency is emitted slightly after the user receives a call on WhatsApp.

```go
type CallRelayLatency struct {
    types.BasicCallMeta
    Data *waBinary.Node
}
```

<a name="CallTerminate"></a>
## type CallTerminate

CallTerminate is emitted when the other party terminates a call on WhatsApp.

```go
type CallTerminate struct {
    types.BasicCallMeta
    Reason string
    Data   *waBinary.Node
}
```

<a name="CallTransport"></a>
## type CallTransport



```go
type CallTransport struct {
    types.BasicCallMeta
    types.CallRemoteMeta

    Data *waBinary.Node
}
```

<a name="ChatPresence"></a>
## type ChatPresence

ChatPresence is emitted when a chat state update \(also known as typing notification\) is received.

Note that WhatsApp won't send you these updates unless you mark yourself as online:

```
client.SendPresence(types.PresenceAvailable)
```

```go
type ChatPresence struct {
    types.MessageSource
    State types.ChatPresence      // The current state, either composing or paused
    Media types.ChatPresenceMedia // When composing, the type of message
}
```

<a name="ClearChat"></a>
## type ClearChat

ClearChat is emitted when a chat is cleared on another device. This is different from DeleteChat.

```go
type ClearChat struct {
    JID       types.JID // The chat which was cleared.
    Timestamp time.Time // The time when the clear happened.

    Action       *waSyncAction.ClearChatAction // Information about the clear.
    FromFullSync bool                          // Whether the action is emitted because of a fullSync
}
```

<a name="ClientOutdated"></a>
## type ClientOutdated

ClientOutdated is emitted when the WhatsApp server rejects the connection with the ConnectFailureClientOutdated code.

```go
type ClientOutdated struct{}
```

<a name="ClientOutdated.PermanentDisconnectDescription"></a>
### func \(\*ClientOutdated\) PermanentDisconnectDescription

```go
func (*ClientOutdated) PermanentDisconnectDescription() string
```



<a name="ConnectFailure"></a>
## type ConnectFailure

ConnectFailure is emitted when the WhatsApp server sends a \<failure\> node with an unknown reason.

Known reasons are handled internally and emitted as different events \(e.g. LoggedOut and TemporaryBan\).

```go
type ConnectFailure struct {
    Reason  ConnectFailureReason
    Message string
    Raw     *waBinary.Node
}
```

<a name="ConnectFailure.PermanentDisconnectDescription"></a>
### func \(\*ConnectFailure\) PermanentDisconnectDescription

```go
func (cf *ConnectFailure) PermanentDisconnectDescription() string
```



<a name="ConnectFailureReason"></a>
## type ConnectFailureReason

ConnectFailureReason is an error code included in connection failure events.

```go
type ConnectFailureReason int
```

<a name="ConnectFailureGeneric"></a>

```go
const (
    ConnectFailureGeneric        ConnectFailureReason = 400
    ConnectFailureLoggedOut      ConnectFailureReason = 401
    ConnectFailureTempBanned     ConnectFailureReason = 402
    ConnectFailureMainDeviceGone ConnectFailureReason = 403 // this is now called LOCKED in the whatsapp web code
    ConnectFailureUnknownLogout  ConnectFailureReason = 406 // this is now called BANNED in the whatsapp web code

    ConnectFailureClientOutdated ConnectFailureReason = 405
    ConnectFailureBadUserAgent   ConnectFailureReason = 409

    ConnectFailureCATExpired ConnectFailureReason = 413
    ConnectFailureCATInvalid ConnectFailureReason = 414
    ConnectFailureNotFound   ConnectFailureReason = 415

    // Status code unknown (not in WA web)
    ConnectFailureClientUnknown ConnectFailureReason = 418

    ConnectFailureInternalServerError ConnectFailureReason = 500
    ConnectFailureExperimental        ConnectFailureReason = 501
    ConnectFailureServiceUnavailable  ConnectFailureReason = 503
)
```

<a name="ConnectFailureReason.IsLoggedOut"></a>
### func \(ConnectFailureReason\) IsLoggedOut

```go
func (cfr ConnectFailureReason) IsLoggedOut() bool
```

IsLoggedOut returns true if the client should delete session data due to this connect failure.

<a name="ConnectFailureReason.NumberString"></a>
### func \(ConnectFailureReason\) NumberString

```go
func (cfr ConnectFailureReason) NumberString() string
```



<a name="ConnectFailureReason.String"></a>
### func \(ConnectFailureReason\) String

```go
func (cfr ConnectFailureReason) String() string
```

String returns the reason code and a short human\-readable description of the error.

<a name="Connected"></a>
## type Connected

Connected is emitted when the client has successfully connected to the WhatsApp servers and is authenticated. The user who the client is authenticated as will be in the device store at this point, which is why this event doesn't contain any data.

```go
type Connected struct{}
```

<a name="Contact"></a>
## type Contact

Contact is emitted when an entry in the user's contact list is modified from another device.

```go
type Contact struct {
    JID       types.JID // The contact who was modified.
    Timestamp time.Time // The time when the modification happened.'

    Action       *waSyncAction.ContactAction // The new contact info.
    FromFullSync bool                        // Whether the action is emitted because of a fullSync
}
```

<a name="DecryptFailMode"></a>
## type DecryptFailMode



```go
type DecryptFailMode string
```

<a name="DecryptFailShow"></a>

```go
const (
    DecryptFailShow DecryptFailMode = ""
    DecryptFailHide DecryptFailMode = "hide"
)
```

<a name="DeleteChat"></a>
## type DeleteChat

DeleteChat is emitted when a chat is deleted on another device.

```go
type DeleteChat struct {
    JID       types.JID // The chat which was deleted.
    Timestamp time.Time // The time when the deletion happened.

    Action       *waSyncAction.DeleteChatAction // Information about the deletion.
    FromFullSync bool                           // Whether the action is emitted because of a fullSync
}
```

<a name="DeleteForMe"></a>
## type DeleteForMe

DeleteForMe is emitted when a message is deleted \(for the current user only\) from another device.

```go
type DeleteForMe struct {
    ChatJID   types.JID // The chat where the message was deleted.
    SenderJID types.JID // In group chats, the user who sent the message (except if the message was sent by the user).
    IsFromMe  bool      // Whether the message was sent by the user.
    MessageID string    // The message which was deleted.
    Timestamp time.Time // The time when the deletion happened.

    Action       *waSyncAction.DeleteMessageForMeAction // Additional information for the deletion.
    FromFullSync bool                                   // Whether the action is emitted because of a fullSync
}
```

<a name="Disconnected"></a>
## type Disconnected

Disconnected is emitted when the websocket is closed by the server.

```go
type Disconnected struct{}
```

<a name="FBMessage"></a>
## type FBMessage



```go
type FBMessage struct {
    Info    types.MessageInfo               // Information about the message like the chat and sender IDs
    Message armadillo.MessageApplicationSub // The actual message struct

    // If the message was re-requested from the sender, this is the number of retries it took.
    RetryCount int

    Transport *waMsgTransport.MessageTransport // The first level of wrapping the message was in

    FBApplication *waMsgApplication.MessageApplication           // The second level of wrapping the message was in, for FB messages
    IGTransport   *instamadilloTransportPayload.TransportPayload // The second level of wrapping the message was in, for IG messages
}
```

<a name="FBMessage.GetArmadillo"></a>
### func \(\*FBMessage\) GetArmadillo

```go
func (evt *FBMessage) GetArmadillo() *waArmadilloApplication.Armadillo
```



<a name="FBMessage.GetConsumerApplication"></a>
### func \(\*FBMessage\) GetConsumerApplication

```go
func (evt *FBMessage) GetConsumerApplication() *waConsumerApplication.ConsumerApplication
```



<a name="GroupInfo"></a>
## type GroupInfo

GroupInfo is emitted when the metadata of a group changes.

```go
type GroupInfo struct {
    JID       types.JID  // The group ID in question
    Notify    string     // Seems like a top-level type for the invite
    Sender    *types.JID // The user who made the change. Doesn't seem to be present when notify=invite
    SenderPN  *types.JID // The phone number of the user who made the change, if Sender is a LID.
    Timestamp time.Time  // The time when the change occurred

    Name      *types.GroupName      // Group name change
    Topic     *types.GroupTopic     // Group topic (description) change
    Locked    *types.GroupLocked    // Group locked status change (can only admins edit group info?)
    Announce  *types.GroupAnnounce  // Group announce status change (can only admins send messages?)
    Ephemeral *types.GroupEphemeral // Disappearing messages change

    MembershipApprovalMode *types.GroupMembershipApprovalMode // Membership approval mode change

    Delete *types.GroupDelete

    Link   *types.GroupLinkChange
    Unlink *types.GroupLinkChange

    NewInviteLink *string // Group invite link change

    PrevParticipantVersionID string
    ParticipantVersionID     string

    JoinReason string // This will be "invite" if the user joined via invite link

    Join  []types.JID // Users who joined or were added the group
    Leave []types.JID // Users who left or were removed from the group

    Promote        []types.JID // Users who were promoted to admins
    Demote         []types.JID // Users who were demoted to normal users
    Suspended      bool        // whether the group is suspended
    Unsuspended    bool        // whether the group is unsuspended
    UnknownChanges []*waBinary.Node
}
```

<a name="HistorySync"></a>
## type HistorySync

HistorySync is emitted when the phone has sent a blob of historical messages.

```go
type HistorySync struct {
    Data *waHistorySync.HistorySync
}
```

<a name="IdentityChange"></a>
## type IdentityChange

IdentityChange is emitted when another user changes their primary device.

```go
type IdentityChange struct {
    JID       types.JID
    Timestamp time.Time

    // Implicit will be set to true if the event was triggered by an untrusted identity error,
    // rather than an identity change notification from the server.
    Implicit bool
}
```

<a name="JoinedGroup"></a>
## type JoinedGroup

JoinedGroup is emitted when you join or are added to a group.

```go
type JoinedGroup struct {
    Reason    string          // If the event was triggered by you using an invite link, this will be "invite".
    Type      string          // "new" if it's a newly created group.
    CreateKey types.MessageID // If you created the group, this is the same message ID you passed to CreateGroup.
    // For type new, the user who created the group and added you to it
    Sender   *types.JID
    SenderPN *types.JID
    Notify   string

    types.GroupInfo
}
```

<a name="KeepAliveRestored"></a>
## type KeepAliveRestored

KeepAliveRestored is emitted if the keepalive pings start working again after some KeepAliveTimeout events. Note that if the websocket disconnects before the pings start working, this event will not be emitted.

```go
type KeepAliveRestored struct{}
```

<a name="KeepAliveTimeout"></a>
## type KeepAliveTimeout

KeepAliveTimeout is emitted when the keepalive ping request to WhatsApp web servers times out.

Currently, there's no automatic handling for these, but it's expected that the TCP connection will either start working again or notice it's dead on its own eventually. Clients may use this event to decide to force a disconnect\+reconnect faster.

```go
type KeepAliveTimeout struct {
    ErrorCount  int
    LastSuccess time.Time
}
```

<a name="LabelAssociationChat"></a>
## type LabelAssociationChat

LabelAssociationChat is emitted when a chat is labeled or unlabeled from any device.

```go
type LabelAssociationChat struct {
    JID       types.JID // The chat which was labeled or unlabeled.
    Timestamp time.Time // The time when the (un)labeling happened.
    LabelID   string    // The label id which was added or removed.

    Action       *waSyncAction.LabelAssociationAction // The current label status of the chat.
    FromFullSync bool                                 // Whether the action is emitted because of a fullSync
}
```

<a name="LabelAssociationMessage"></a>
## type LabelAssociationMessage

LabelAssociationMessage is emitted when a message is labeled or unlabeled from any device.

```go
type LabelAssociationMessage struct {
    JID       types.JID // The chat which was labeled or unlabeled.
    Timestamp time.Time // The time when the (un)labeling happened.
    LabelID   string    // The label id which was added or removed.
    MessageID string    // The message id which was labeled or unlabeled.

    Action       *waSyncAction.LabelAssociationAction // The current label status of the message.
    FromFullSync bool                                 // Whether the action is emitted because of a fullSync
}
```

<a name="LabelEdit"></a>
## type LabelEdit

LabelEdit is emitted when a label is edited from any device.

```go
type LabelEdit struct {
    Timestamp time.Time // The time when the label was edited.
    LabelID   string    // The label id which was edited.

    Action       *waSyncAction.LabelEditAction // The new label info.
    FromFullSync bool                          // Whether the action is emitted because of a fullSync
}
```

<a name="LoggedOut"></a>
## type LoggedOut

LoggedOut is emitted when the client has been unpaired from the phone.

This can happen while connected \(stream:error messages\) or right after connecting \(connect failure messages\).

This will not be emitted when the logout is initiated by this client \(using Client.LogOut\(\)\).

```go
type LoggedOut struct {
    // OnConnect is true if the event was triggered by a connect failure message.
    // If it's false, the event was triggered by a stream:error message.
    OnConnect bool
    // If OnConnect is true, then this field contains the reason code.
    Reason ConnectFailureReason
}
```

<a name="LoggedOut.PermanentDisconnectDescription"></a>
### func \(\*LoggedOut\) PermanentDisconnectDescription

```go
func (l *LoggedOut) PermanentDisconnectDescription() string
```



<a name="ManualLoginReconnect"></a>
## type ManualLoginReconnect

ManualLoginReconnect is emitted after login if DisableLoginAutoReconnect is set.

```go
type ManualLoginReconnect struct{}
```

<a name="MarkChatAsRead"></a>
## type MarkChatAsRead

MarkChatAsRead is emitted when a whole chat is marked as read or unread from another device.

```go
type MarkChatAsRead struct {
    JID       types.JID // The chat which was marked as read or unread.
    Timestamp time.Time // The time when the marking happened.

    Action       *waSyncAction.MarkChatAsReadAction // Whether the chat was marked as read or unread, and info about the most recent messages.
    FromFullSync bool                               // Whether the action is emitted because of a fullSync
}
```

<a name="MediaRetry"></a>
## type MediaRetry

MediaRetry is emitted when the phone sends a response to a media retry request.

```go
type MediaRetry struct {
    Ciphertext []byte
    IV         []byte

    // Sometimes there's an unencrypted media retry error. In these cases, Ciphertext and IV will be nil.
    Error *MediaRetryError

    Timestamp time.Time // The time of the response.

    MessageID types.MessageID // The ID of the message.
    ChatID    types.JID       // The chat ID where the message was sent.
    SenderID  types.JID       // The user who sent the message. Only present in groups.
    FromMe    bool            // Whether the message was sent by the current user or someone else.
}
```

<a name="MediaRetryError"></a>
## type MediaRetryError



```go
type MediaRetryError struct {
    Code int
}
```

<a name="Message"></a>
## type Message

Message is emitted when receiving a new message.

```go
type Message struct {
    Info    types.MessageInfo // Information about the message like the chat and sender IDs
    Message *waE2E.Message    // The actual message struct

    IsEphemeral           bool // True if the message was unwrapped from an EphemeralMessage
    IsViewOnce            bool // True if the message was unwrapped from a ViewOnceMessage, ViewOnceMessageV2 or ViewOnceMessageV2Extension
    IsViewOnceV2          bool // True if the message was unwrapped from a ViewOnceMessageV2 or ViewOnceMessageV2Extension
    IsViewOnceV2Extension bool // True if the message was unwrapped from a ViewOnceMessageV2Extension
    IsDocumentWithCaption bool // True if the message was unwrapped from a DocumentWithCaptionMessage
    IsLottieSticker       bool // True if the message was unwrapped from a LottieStickerMessage
    IsBotInvoke           bool // True if the message was unwrapped from a BotInvokeMessage
    IsEdit                bool // True if the message was unwrapped from an EditedMessage

    // If this event was parsed from a WebMessageInfo (i.e. from a history sync or unavailable message request), the source data is here.
    SourceWebMsg *waWeb.WebMessageInfo
    // If this event is a response to an unavailable message request, the request ID is here.
    UnavailableRequestID types.MessageID
    // If the message was re-requested from the sender, this is the number of retries it took.
    RetryCount int

    NewsletterMeta *NewsletterMessageMeta

    // The raw message struct. This is the raw unmodified data, which means the actual message might
    // be wrapped in DeviceSentMessage, EphemeralMessage or ViewOnceMessage.
    RawMessage *waE2E.Message
}
```

<a name="Message.UnwrapRaw"></a>
### func \(\*Message\) UnwrapRaw

```go
func (evt *Message) UnwrapRaw() *Message
```

UnwrapRaw fills the Message, IsEphemeral and IsViewOnce fields based on the raw message in the RawMessage field.

<a name="Mute"></a>
## type Mute

Mute is emitted when a chat is muted or unmuted from another device.

```go
type Mute struct {
    JID       types.JID // The chat which was muted or unmuted.
    Timestamp time.Time // The time when the (un)muting happened.

    Action       *waSyncAction.MuteAction // The current mute status of the chat.
    FromFullSync bool                     // Whether the action is emitted because of a fullSync
}
```

<a name="NewsletterJoin"></a>
## type NewsletterJoin



```go
type NewsletterJoin struct {
    types.NewsletterMetadata
}
```

<a name="NewsletterLeave"></a>
## type NewsletterLeave



```go
type NewsletterLeave struct {
    ID   types.JID            `json:"id"`
    Role types.NewsletterRole `json:"role"`
}
```

<a name="NewsletterLiveUpdate"></a>
## type NewsletterLiveUpdate



```go
type NewsletterLiveUpdate struct {
    JID      types.JID
    Time     time.Time
    Messages []*types.NewsletterMessage
}
```

<a name="NewsletterMessageMeta"></a>
## type NewsletterMessageMeta



```go
type NewsletterMessageMeta struct {
    // When a newsletter message is edited, the message isn't wrapped in an EditedMessage like normal messages.
    // Instead, the message is the new content, the ID is the original message ID, and the edit timestamp is here.
    EditTS time.Time
    // This is the timestamp of the original message for edits.
    OriginalTS time.Time
}
```

<a name="NewsletterMuteChange"></a>
## type NewsletterMuteChange



```go
type NewsletterMuteChange struct {
    ID   types.JID                 `json:"id"`
    Mute types.NewsletterMuteState `json:"mute"`
}
```

<a name="OfflineSyncCompleted"></a>
## type OfflineSyncCompleted

OfflineSyncCompleted is emitted after the server has finished sending missed events.

```go
type OfflineSyncCompleted struct {
    Count int
}
```

<a name="OfflineSyncPreview"></a>
## type OfflineSyncPreview

OfflineSyncPreview is emitted right after connecting if the server is going to send events that the client missed during downtime.

```go
type OfflineSyncPreview struct {
    Total int

    AppDataChanges int
    Messages       int
    Notifications  int
    Receipts       int
}
```

<a name="PairError"></a>
## type PairError

PairError is emitted when a pair\-success event is received from the server, but finishing the pairing locally fails.

```go
type PairError struct {
    ID           types.JID
    LID          types.JID
    BusinessName string
    Platform     string
    Error        error
}
```

<a name="PairSuccess"></a>
## type PairSuccess

PairSuccess is emitted after the QR code has been scanned with the phone and the handshake has been completed. Note that this is generally followed by a websocket reconnection, so you should wait for the Connected before trying to send anything.

```go
type PairSuccess struct {
    ID           types.JID
    LID          types.JID
    BusinessName string
    Platform     string
}
```

<a name="PermanentDisconnect"></a>
## type PermanentDisconnect

PermanentDisconnect is a class of events emitted when the client will not auto\-reconnect by default.

```go
type PermanentDisconnect interface {
    PermanentDisconnectDescription() string
}
```

<a name="Picture"></a>
## type Picture

Picture is emitted when a user's profile picture or group's photo is changed.

You can use Client.GetProfilePictureInfo to get the actual image URL after this event.

```go
type Picture struct {
    JID       types.JID // The user or group ID where the picture was changed.
    Author    types.JID // The user who changed the picture.
    Timestamp time.Time // The timestamp when the picture was changed.
    Remove    bool      // True if the picture was removed.
    PictureID string    // The new picture ID if it was not removed.
}
```

<a name="Pin"></a>
## type Pin

Pin is emitted when a chat is pinned or unpinned from another device.

```go
type Pin struct {
    JID       types.JID // The chat which was pinned or unpinned.
    Timestamp time.Time // The time when the (un)pinning happened.

    Action       *waSyncAction.PinAction // Whether the chat is now pinned or not.
    FromFullSync bool                    // Whether the action is emitted because of a fullSync
}
```

<a name="Presence"></a>
## type Presence

Presence is emitted when a presence update is received.

Note that WhatsApp only sends you presence updates for individual users after you subscribe to them:

```
client.SubscribePresence(user JID)
```

```go
type Presence struct {
    // The user whose presence event this is
    From types.JID
    // True if the user is now offline
    Unavailable bool
    // The time when the user was last online. This may be the zero value if the user has hid their last seen time.
    LastSeen time.Time
}
```

<a name="PrivacySettings"></a>
## type PrivacySettings

PrivacySettings is emitted when the user changes their privacy settings.

```go
type PrivacySettings struct {
    NewSettings         types.PrivacySettings
    GroupAddChanged     bool
    LastSeenChanged     bool
    StatusChanged       bool
    ProfileChanged      bool
    ReadReceiptsChanged bool
    OnlineChanged       bool
    CallAddChanged      bool
}
```

<a name="PushName"></a>
## type PushName

PushName is emitted when a message is received with a different push name than the previous value cached for the same user.

```go
type PushName struct {
    JID         types.JID // The user whose push name changed.
    JIDAlt      types.JID
    Message     *types.MessageInfo // The message where this change was first noticed.
    OldPushName string             // The previous push name from the local cache.
    NewPushName string             // The new push name that was included in the message.
}
```

<a name="PushNameSetting"></a>
## type PushNameSetting

PushNameSetting is emitted when the user's push name is changed from another device.

```go
type PushNameSetting struct {
    Timestamp time.Time // The time when the push name was changed.

    Action       *waSyncAction.PushNameSetting // The new push name for the user.
    FromFullSync bool                          // Whether the action is emitted because of a fullSync
}
```

<a name="QR"></a>
## type QR

QR is emitted after connecting when there's no session data in the device store.

The QR codes are available in the Codes slice. You should render the strings as QR codes one by one, switching to the next one whenever enough time has passed. WhatsApp web seems to show the first code for 60 seconds and all other codes for 20 seconds.

When the QR code has been scanned and pairing is complete, PairSuccess will be emitted. If you run out of codes before scanning, the server will close the websocket, and you will have to reconnect to get more codes.

```go
type QR struct {
    Codes []string
}
```

<a name="QRScannedWithoutMultidevice"></a>
## type QRScannedWithoutMultidevice

QRScannedWithoutMultidevice is emitted when the pairing QR code is scanned, but the phone didn't have multidevice enabled. The same QR code can still be scanned after this event, which means the user can just be told to enable multidevice and re\-scan the code.

```go
type QRScannedWithoutMultidevice struct{}
```

<a name="Receipt"></a>
## type Receipt

Receipt is emitted when an outgoing message is delivered to or read by another user, or when another device reads an incoming message.

N.B. WhatsApp on Android sends message IDs from newest message to oldest, but WhatsApp on iOS sends them in the opposite order \(oldest first\).

```go
type Receipt struct {
    types.MessageSource
    MessageIDs []types.MessageID
    Timestamp  time.Time
    Type       types.ReceiptType

    // When you read the message of another user in a group, this field contains the sender of the message.
    // For receipts from other users, the message sender is always you.
    MessageSender types.JID
}
```

<a name="ReceiptType"></a>
## type ReceiptType

Deprecated: use types.ReceiptType directly

```go
type ReceiptType = types.ReceiptType
```

<a name="Star"></a>
## type Star

Star is emitted when a message is starred or unstarred from another device.

```go
type Star struct {
    ChatJID   types.JID // The chat where the message was pinned.
    SenderJID types.JID // In group chats, the user who sent the message (except if the message was sent by the user).
    IsFromMe  bool      // Whether the message was sent by the user.
    MessageID string    // The message which was starred or unstarred.
    Timestamp time.Time // The time when the (un)starring happened.

    Action       *waSyncAction.StarAction // Whether the message is now starred or not.
    FromFullSync bool                     // Whether the action is emitted because of a fullSync
}
```

<a name="StreamError"></a>
## type StreamError

StreamError is emitted when the WhatsApp server sends a \<stream:error\> node with an unknown code.

Known codes are handled internally and emitted as different events \(e.g. LoggedOut\).

```go
type StreamError struct {
    Code string
    Raw  *waBinary.Node
}
```

<a name="StreamReplaced"></a>
## type StreamReplaced

StreamReplaced is emitted when the client is disconnected by another client connecting with the same keys.

This can happen if you accidentally start another process with the same session or otherwise try to connect twice with the same session.

```go
type StreamReplaced struct{}
```

<a name="StreamReplaced.PermanentDisconnectDescription"></a>
### func \(\*StreamReplaced\) PermanentDisconnectDescription

```go
func (*StreamReplaced) PermanentDisconnectDescription() string
```



<a name="TempBanReason"></a>
## type TempBanReason

TempBanReason is an error code included in temp ban error events.

```go
type TempBanReason int
```

<a name="TempBanSentToTooManyPeople"></a>

```go
const (
    TempBanSentToTooManyPeople    TempBanReason = 101
    TempBanBlockedByUsers         TempBanReason = 102
    TempBanCreatedTooManyGroups   TempBanReason = 103
    TempBanSentTooManySameMessage TempBanReason = 104
    TempBanBroadcastList          TempBanReason = 106
)
```

<a name="TempBanReason.String"></a>
### func \(TempBanReason\) String

```go
func (tbr TempBanReason) String() string
```

String returns the reason code and a human\-readable description of the ban reason.

<a name="TemporaryBan"></a>
## type TemporaryBan

TemporaryBan is emitted when there's a connection failure with the ConnectFailureTempBanned reason code.

```go
type TemporaryBan struct {
    Code   TempBanReason
    Expire time.Duration
}
```

<a name="TemporaryBan.PermanentDisconnectDescription"></a>
### func \(\*TemporaryBan\) PermanentDisconnectDescription

```go
func (tb *TemporaryBan) PermanentDisconnectDescription() string
```



<a name="TemporaryBan.String"></a>
### func \(\*TemporaryBan\) String

```go
func (tb *TemporaryBan) String() string
```



<a name="UnarchiveChatsSetting"></a>
## type UnarchiveChatsSetting

UnarchiveChatsSetting is emitted when the user changes the "Keep chats archived" setting from another device.

```go
type UnarchiveChatsSetting struct {
    Timestamp time.Time // The time when the setting was changed.

    Action       *waSyncAction.UnarchiveChatsSetting // The new settings.
    FromFullSync bool                                // Whether the action is emitted because of a fullSync
}
```

<a name="UnavailableType"></a>
## type UnavailableType



```go
type UnavailableType string
```

<a name="UnavailableTypeUnknown"></a>

```go
const (
    UnavailableTypeUnknown  UnavailableType = ""
    UnavailableTypeViewOnce UnavailableType = "view_once"
)
```

<a name="UndecryptableMessage"></a>
## type UndecryptableMessage

UndecryptableMessage is emitted when receiving a new message that failed to decrypt.

The library will automatically ask the sender to retry. If the sender resends the message, and it's decryptable, then it will be emitted as a normal Message event.

The UndecryptableMessage event may also be repeated if the resent message is also undecryptable.

```go
type UndecryptableMessage struct {
    Info types.MessageInfo

    // IsUnavailable is true if the recipient device didn't send a ciphertext to this device at all
    // (as opposed to sending a ciphertext, but the ciphertext not being decryptable).
    IsUnavailable bool
    // Some message types are intentionally unavailable. Such types usually have a type specified here.
    UnavailableType UnavailableType

    DecryptFailMode DecryptFailMode
}
```

<a name="UnknownCallEvent"></a>
## type UnknownCallEvent

UnknownCallEvent is emitted when a call element with unknown content is received.

```go
type UnknownCallEvent struct {
    Node *waBinary.Node
}
```

<a name="UserAbout"></a>
## type UserAbout

UserAbout is emitted when a user's about status is changed.

```go
type UserAbout struct {
    JID       types.JID // The user whose status was changed
    Status    string    // The new status
    Timestamp time.Time // The timestamp when the status was changed.
}
```

<a name="UserStatusMute"></a>
## type UserStatusMute

UserStatusMute is emitted when the user mutes or unmutes another user's status updates.

```go
type UserStatusMute struct {
    JID       types.JID // The user who was muted or unmuted
    Timestamp time.Time // The timestamp when the action happened

    Action       *waSyncAction.UserStatusMuteAction // The new mute status
    FromFullSync bool                               // Whether the action is emitted because of a fullSync
}
```

# waLog

```go
import "go.mau.fi/whatsmeow/util/log"
```

Package waLog contains a simple logger interface used by the other whatsmeow packages.

## Index

- [type Logger](<#Logger>)
  - [func Stdout\(module string, minLevel string, color bool\) Logger](<#Stdout>)
  - [func Zerolog\(log zerolog.Logger\) Logger](<#Zerolog>)


<a name="Logger"></a>
## type Logger

Logger is a simple logger interface that can have subloggers for specific areas.

```go
type Logger interface {
    Warnf(msg string, args ...interface{})
    Errorf(msg string, args ...interface{})
    Infof(msg string, args ...interface{})
    Debugf(msg string, args ...interface{})
    Sub(module string) Logger
}
```

<a name="Noop"></a>Noop is a no\-op Logger implementation that silently drops everything.

```go
var Noop Logger = &noopLogger{}
```

<a name="Stdout"></a>
### func Stdout

```go
func Stdout(module string, minLevel string, color bool) Logger
```

Stdout is a simple Logger implementation that outputs to stdout. The module name given is included in log lines.

minLevel specifies the minimum log level to output. An empty string will output all logs.

If color is true, then info, warn and error logs will be colored cyan, yellow and red respectively using ANSI color escape codes.

<a name="Zerolog"></a>
### func Zerolog

```go
func Zerolog(log zerolog.Logger) Logger
```

Zerolog wraps a \[zerolog.Logger\] to implement the [Logger](<#Logger>) interface.

Subloggers will be created by setting the \`sublogger\` field in the log context.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
